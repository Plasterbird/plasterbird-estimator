<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plasterbird Master System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }

        #app {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 350px;
            background: #2a2a2a;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #444;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo-bird {
            width: 40px;
            height: 40px;
            background: #00d4ff;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
        }

        .logo-bird::before {
            content: '';
            position: absolute;
            width: 15px;
            height: 15px;
            background: #fff;
            border-radius: 50%;
            top: 12px;
            left: 8px;
        }

        .logo-bird::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 15px solid #00d4ff;
            bottom: -10px;
            right: 10px;
            transform: rotate(45deg);
        }

        .sidebar-header h2 {
            font-size: 18px;
            color: #00d4ff;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        /* Page Selector */
        .page-selector {
            position: absolute;
            top: 80px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #444;
            border-radius: 6px;
            overflow: hidden;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .page-selector.collapsed {
            width: 40px;
            height: 40px;
        }

        .page-selector.expanded {
            width: 200px;
            max-height: 400px;
        }

        .page-selector-toggle {
            width: 40px;
            height: 40px;
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .page-selector-toggle:hover {
            background: #333;
        }

        .page-list {
            display: none;
            max-height: 350px;
            overflow-y: auto;
        }

        .page-selector.expanded .page-list {
            display: block;
        }

        .page-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #333;
            font-size: 12px;
        }

        .page-item:hover {
            background: #333;
        }

        .page-item.active {
            background: #00d4ff20;
            border-left: 3px solid #00d4ff;
        }

        .page-thumbnail {
            width: 100%;
            height: 80px;
            background: #1a1a1a;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 10px;
            position: relative;
        }

        .page-thumbnail canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .page-name {
            font-weight: 600;
            color: #00d4ff;
        }

        /* Tabs */
        .tabs {
            display: flex;
            background: #1a1a1a;
            border-bottom: 1px solid #444;
        }

        .tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            border: none;
            background: transparent;
            color: #999;
            font-weight: 600;
            transition: all 0.3s;
        }

        .tab:hover {
            background: #333;
        }

        .tab.active {
            color: #00d4ff;
            border-bottom: 2px solid #00d4ff;
        }

        .tab-content {
            display: none;
            height: 100%;
        }

        .tab-content.active {
            display: block;
        }

        /* Right Panel */
        .right-panel {
            width: 350px;
            background: #2a2a2a;
            border-left: 1px solid #444;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 15px 20px;
            background: #1a1a1a;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-header h3 {
            font-size: 16px;
            color: #00d4ff;
        }

        .panel-toggle {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 20px;
            padding: 0 5px;
        }

        .panel-toggle:hover {
            color: #00d4ff;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        /* Sections */
        .section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Icon Buttons */
        .icon-btn {
            width: 40px;
            height: 40px;
            background: #333;
            border: 1px solid #444;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            position: relative;
        }

        .icon-btn:hover {
            background: #00d4ff;
            color: #000;
        }

        .icon-btn.active {
            background: #00d4ff;
            color: #000;
            border-color: #00d4ff;
        }

        .tooltip {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: #000;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .icon-btn:hover .tooltip {
            opacity: 1;
        }

        /* Upload Section */
        .upload-section {
            display: flex;
            gap: 10px;
        }

        input[type="file"] {
            display: none;
        }

        /* Tool Grid */
        .tool-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .tool-btn {
            padding: 15px 10px;
            background: #333;
            border: 2px solid #444;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .tool-btn:hover {
            background: #444;
        }

        .tool-btn.active {
            background: #00d4ff;
            color: #000;
            border-color: #00d4ff;
        }

        .tool-btn svg {
            width: 24px;
            height: 24px;
        }

        /* Drawing Style Dialog */
        .style-dialog {
            position: absolute;
            top: 60px;
            left: 20px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            min-width: 250px;
            display: none;
            z-index: 100;
        }

        .style-dialog.show {
            display: block;
        }

        .style-dialog h4 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .line-width-options {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .line-width-option {
            flex: 1;
            height: 40px;
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .line-width-option:hover {
            background: #444;
        }

        .line-width-option.active {
            border-color: #00d4ff;
            background: #00d4ff20;
        }

        .line-preview {
            width: 30px;
            background: #fff;
            border-radius: 2px;
        }

        .opacity-control {
            margin-top: 15px;
        }

        .opacity-preview {
            width: 100%;
            height: 30px;
            border-radius: 4px;
            margin-bottom: 10px;
            border: 1px solid #444;
        }

        .opacity-slider {
            width: 100%;
            height: 6px;
            background: #444;
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
        }

        .opacity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Aquacheck Controls */
        .aquacheck-controls {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 12px;
            font-size: 13px;
        }

        .aquacheck-option {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .aquacheck-option:last-child {
            margin-bottom: 0;
        }

        .aquacheck-option input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* Count Style Controls */
        .shape-selector {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin-top: 5px;
        }

        .shape-btn {
            width: 30px;
            height: 30px;
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
        }

        .shape-btn:hover {
            background: #444;
        }

        .shape-btn.active {
            background: #00d4ff;
            color: #000;
            border-color: #00d4ff;
        }

        /* Item Categories */
        .item-category {
            margin-bottom: 15px;
        }

        .category-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            background: #333;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
        }

        .category-header:hover {
            background: #3a3a3a;
        }

        .category-arrow {
            font-size: 12px;
            transition: transform 0.3s;
        }

        .category-arrow.open {
            transform: rotate(90deg);
        }

        .category-items {
            display: none;
            margin-top: 5px;
            max-height: 300px;
            overflow-y: auto;
        }

        .category-items.open {
            display: block;
        }

        .item-option {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
        }

        .item-option:hover {
            background: #2a2a2a;
        }

        .item-option.selected {
            background: #00d4ff20;
            border-color: #00d4ff;
        }

        .item-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            margin-right: 10px;
            border: 1px solid #444;
            flex-shrink: 0;
        }

        /* Canvas Container */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #0a0a0a;
        }

        #pdfCanvas, #drawingCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            cursor: crosshair;
        }

        #drawingCanvas {
            pointer-events: all;
        }

        /* House Info Panel */
        .house-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            min-width: 250px;
            display: none;
        }

        .house-info.show {
            display: block;
        }

        .house-info h4 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-house-info {
            background: none;
            border: none;
            color: #999;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-house-info:hover {
            color: #fff;
        }

        .info-row {
            margin-bottom: 15px;
        }

        .info-row label {
            display: block;
            color: #999;
            font-size: 12px;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .info-row select, .info-row input {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
        }

        /* Action Controls */
        .action-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .action-btn {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 50%;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            position: relative;
        }

        .action-btn:hover {
            background: #00d4ff;
            color: #000;
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Current Selection Display */
        .current-selection {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 6px;
            color: #fff;
            padding: 8px 12px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .current-selection .item-color {
            width: 20px;
            height: 20px;
        }

        .selection-label {
            color: #999;
            font-size: 11px;
            margin-right: 5px;
        }

        /* Finish Selector */
        .finish-selector {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 4px 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .finish-selector label {
            color: #999;
            font-size: 11px;
        }

        .finish-selector select {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 4px 8px;
            font-size: 12px;
            margin: 0;
            min-width: 120px;
            color: #fff;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 50%;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .zoom-btn:hover {
            background: #00d4ff;
            color: #000;
        }

        /* Measurements List */
        .measurements-group {
            margin-bottom: 15px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            overflow: hidden;
        }

        .measurements-group.highlighted {
            border-color: #00d4ff;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }

        .group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: #2a2a2a;
            cursor: pointer;
            user-select: none;
        }

        .group-header:hover {
            background: #333;
        }

        .group-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }

        .group-arrow {
            font-size: 12px;
            transition: transform 0.3s;
        }

        .group-arrow.open {
            transform: rotate(90deg);
        }

        .group-name {
            flex: 1;
            font-weight: 500;
        }

        .group-name-input {
            background: #1a1a1a;
            border: 1px solid #00d4ff;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
            width: 150px;
        }

        .group-total {
            font-size: 13px;
            color: #00d4ff;
            font-weight: 600;
            margin-left: 10px;
        }

        .group-actions {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .visibility-toggle {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
        }

        .visibility-toggle:hover {
            color: #00d4ff;
        }

        .visibility-toggle.visible {
            color: #00d4ff;
        }

        .group-delete {
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            padding: 4px 8px;
            font-size: 11px;
        }

        .group-delete:hover {
            background: #ff4444;
            border-color: #ff4444;
        }

        .group-items {
            display: none;
        }

        .group-items.open {
            display: block;
        }

        .measurement-item {
            padding: 8px 20px;
            border-top: 1px solid #333;
            font-size: 12px;
            color: #ccc;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .measurement-item:hover {
            background: #1f1f1f;
            color: #fff;
        }

        .measurement-item.highlighted {
            background: #00d4ff20;
            color: #00d4ff;
        }

        .measurement-info {
            display: flex;
            gap: 10px;
            align-items: center;
            flex: 1;
        }

        .measurement-length {
            color: #00d4ff;
            font-weight: 600;
        }

        .measurement-delete {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 16px;
            padding: 0 4px;
        }

        .measurement-delete:hover {
            color: #ff4444;
        }

        /* Room Group */
        .room-group {
            margin-bottom: 10px;
        }

        .room-header {
            padding: 8px 20px;
            background: #0a0a0a;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .room-header:hover {
            background: #1a1a1a;
        }

        .room-header.highlighted {
            background: #00d4ff20;
        }

        .room-name {
            font-weight: 600;
            color: #fff;
        }

        .room-arrow {
            color: #666;
            font-size: 11px;
            transition: transform 0.3s;
        }

        .room-arrow.open {
            transform: rotate(180deg);
        }

        .room-details {
            padding-left: 30px;
            background: #0a0a0a;
        }

        .room-detail-item {
            padding: 6px 10px;
            font-size: 11px;
            color: #999;
            display: flex;
            justify-content: space-between;
        }

        .detail-label {
            font-weight: 500;
        }

        .detail-value {
            color: #00d4ff;
        }

        /* Loading Indicator */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #666;
        }

        /* Dialogs */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .scale-dialog {
            background: #2a2a2a;
            border: 2px solid #00d4ff;
            border-radius: 8px;
            padding: 30px;
            min-width: 400px;
        }

        .scale-dialog h3 {
            margin-bottom: 20px;
            color: #00d4ff;
            text-align: center;
        }

        .dialog-section {
            margin-bottom: 20px;
        }

        .dialog-section label {
            display: block;
            margin-bottom: 8px;
            color: #999;
            font-size: 14px;
        }

        .scale-dialog input {
            width: 100%;
            margin: 0;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
        }

        .scale-dialog-buttons {
            margin-top: 25px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .scale-dialog button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
        }

        .scale-dialog .confirm-btn {
            background: #00d4ff;
            color: #000;
        }

        .scale-dialog .cancel-btn {
            background: #666;
            color: #fff;
        }

        /* Room Name Dialog */
        .room-name-dialog {
            position: fixed;
            background: #2a2a2a;
            border: 2px solid #00d4ff;
            border-radius: 8px;
            padding: 20px;
            min-width: 300px;
            z-index: 1001;
            cursor: default;
        }

        .room-name-dialog h3 {
            margin-bottom: 15px;
            color: #00d4ff;
            font-size: 16px;
        }

        .room-name-dialog input {
            width: 100%;
            margin: 0;
            margin-bottom: 15px;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
        }

        .dialog-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: move;
        }

        /* Billing Window */
        .billing-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            z-index: 1001;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .billing-header {
            padding: 15px 20px;
            background: #1a1a1a;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }

        .billing-header h3 {
            color: #00d4ff;
            font-size: 18px;
        }

        .billing-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .billing-table {
            width: 100%;
            border-collapse: collapse;
        }

        .billing-table th {
            background: #1a1a1a;
            padding: 10px;
            text-align: left;
            font-size: 12px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid #444;
        }

        .billing-row {
            border-bottom: 1px solid #333;
            cursor: move;
        }

        .billing-row:hover {
            background: #333;
        }

        .billing-row.dragging {
            opacity: 0.5;
        }

        .billing-row td {
            padding: 12px 10px;
            font-size: 14px;
        }

        .billing-row input {
            background: transparent;
            border: none;
            color: #fff;
            width: 100%;
            padding: 4px;
        }

        .billing-row input:focus {
            background: #1a1a1a;
            border: 1px solid #00d4ff;
            border-radius: 4px;
        }

        .billing-totals {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #444;
        }

        .billing-total-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 16px;
        }

        .billing-total-row.grand-total {
            font-size: 20px;
            font-weight: 600;
            color: #00d4ff;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #444;
        }

        /* Estimate Window */
        .estimate-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            width: 800px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            z-index: 1002;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .estimate-header {
            padding: 20px;
            background: #1a1a1a;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .estimate-header h2 {
            color: #00d4ff;
            font-size: 24px;
        }

        .estimate-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .page-section {
            margin-bottom: 30px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }

        .page-section-header {
            padding: 15px;
            background: #333;
            font-size: 18px;
            font-weight: 600;
            color: #00d4ff;
        }

        .page-section-content {
            padding: 15px;
        }

        /* Items Editor */
        .items-editor-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1002;
        }

        .items-editor {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            width: 80%;
            max-width: 900px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .items-editor-header {
            padding: 20px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .items-editor-header h3 {
            color: #00d4ff;
            font-size: 20px;
        }

        .close-btn {
            background: none;
            border: none;
            color: #999;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: #fff;
        }

        .items-editor-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .items-category {
            margin-bottom: 30px;
        }

        .items-category h4 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .item-row {
            display: grid;
            grid-template-columns: 30px 1fr 100px 100px 100px 40px;
            gap: 10px;
            align-items: center;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .item-row input[type="color"] {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .item-row input[type="text"], .item-row input[type="number"], .item-row select {
            padding: 6px;
            background: #0a0a0a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 13px;
        }

        .delete-item-btn {
            background: #ff4444;
            border: none;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .delete-item-btn:hover {
            background: #ff6666;
        }

        .add-item-btn {
            background: #00d4ff;
            border: none;
            color: #000;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
        }

        .add-item-btn:hover {
            background: #4de4ff;
        }

        /* Panel Collapse */
        .right-panel.collapsed {
            width: 40px;
        }

        .right-panel.collapsed .panel-content,
        .right-panel.collapsed .panel-header h3 {
            display: none;
        }

        .right-panel.collapsed .panel-header {
            justify-content: center;
        }

        /* Polygon Options */
        .polygon-options {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 12px;
            margin-top: 10px;
        }

        .polygon-option-label {
            font-size: 12px;
            color: #999;
            margin-bottom: 5px;
            display: block;
        }

        .wall-segments-list {
            margin-top: 10px;
            font-size: 12px;
            color: #999;
        }

        .wall-segment {
            padding: 4px 8px;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            margin-bottom: 4px;
        }

        /* Compact Controls */
        .compact-control {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .compact-control:hover {
            background: #333;
            border-color: #00d4ff;
        }

        .compact-control-icon {
            width: 24px;
            height: 24px;
            color: #00d4ff;
            flex-shrink: 0;
        }

        .compact-control-value {
            color: #fff;
            font-weight: 600;
            font-size: 14px;
        }

        /* Aquacheck Popup */
        .aquacheck-popup {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 12px;
            margin-top: 4px;
            display: none;
            z-index: 10;
        }

        .aquacheck-popup.show {
            display: block;
        }

        /* Reminder Dialog */
        .reminder-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 2px solid #ff9900;
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            z-index: 1003;
        }

        .reminder-dialog h3 {
            color: #ff9900;
            margin-bottom: 20px;
            font-size: 18px;
        }

        .reminder-list {
            margin: 20px 0;
        }

        .reminder-item {
            padding: 8px 0;
            color: #ccc;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .reminder-item::before {
            content: '⚠';
            color: #ff9900;
            font-size: 16px;
        }

        .reminder-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .reminder-buttons button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
        }

        .reminder-continue {
            background: #00d4ff;
            color: #000;
        }

        .reminder-cancel {
            background: #666;
            color: #fff;
        }

        /* Openings Dialog */
        .openings-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 2px solid #00d4ff;
            border-radius: 8px;
            padding: 20px;
            min-width: 300px;
            z-index: 1001;
        }

        .openings-dialog h3 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .openings-dialog input {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            margin-bottom: 15px;
        }

        /* Profile Editor in Items */
        .profile-editor {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .profile-editor label {
            color: #999;
            font-size: 14px;
        }

        .profile-editor select {
            background: #0a0a0a;
            border: 1px solid #333;
            color: #fff;
            padding: 6px 12px;
            border-radius: 4px;
            min-width: 150px;
        }

        .profile-editor button {
            background: #00d4ff;
            border: none;
            color: #000;
            padding: 6px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
        }

        .profile-editor button:hover {
            background: #4de4ff;
        }

        /* Export button in items editor */
        .export-pdf-btn {
            position: absolute;
            top: 20px;
            right: 60px;
            background: #00d4ff;
            border: none;
            color: #000;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }

        .export-pdf-btn:hover {
            background: #4de4ff;
        }

        /* Hide class for measurements */
        .measurement-hidden {
            opacity: 0.3;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Left Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="logo-bird"></div>
                <h2>Plasterbird Master System</h2>
            </div>
            
            <div class="sidebar-content">
                <!-- Plan Setup -->
                <div class="section">
                    <div class="section-title">Plan Setup</div>
                    <div class="upload-section">
                        <label for="pdfUpload" class="icon-btn">
                            <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                            </svg>
                            <span class="tooltip">Choose PDF</span>
                        </label>
                        <button class="icon-btn" onclick="selectScaleTool()">
                            <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M7,2V4H17V2H19V5H20V7H19V9H17V7H7V9H5V7H4V5H5V2H7M7,11V13H9V11H11V13H13V11H15V13H17V11H19V16H20V18H19V20H17V18H7V20H5V18H4V16H5V11H7Z"/>
                            </svg>
                            <span class="tooltip">Set Scale</span>
                        </button>
                        <button class="icon-btn" onclick="openOpeningsDialog()">
                            <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                                <rect x="3" y="8" width="18" height="13" />
                                <path d="M3 8L12 3L21 8"/>
                                <rect x="8" y="13" width="8" height="8" fill="currentColor" opacity="0.3"/>
                            </svg>
                            <span class="tooltip">Openings</span>
                        </button>
                    </div>
                    <input type="file" id="pdfUpload" accept=".pdf">
                </div>

                <!-- Drawing Tools -->
                <div class="section">
                    <div class="section-title">Drawing Tools</div>
                    <div class="tool-grid">
                        <button class="tool-btn active" data-tool="move">
                            <svg fill="currentColor" viewBox="0 0 24 24">
                                <path d="M10,9V5L3,12L10,19V14.9C15,14.9 18.5,16.5 21,20C20,15 17,10 10,9Z"/>
                            </svg>
                            Move
                        </button>
                        <button class="tool-btn" data-tool="line" style="display: none;">
                            <svg fill="currentColor" viewBox="0 0 24 24">
                                <path d="M3.5 3.5L20.5 20.5M20.5 20.5L20.5 14.5M20.5 20.5L14.5 20.5" stroke="currentColor" stroke-width="2" fill="none"/>
                            </svg>
                            Line
                        </button>
                        <button class="tool-btn" data-tool="polygon" style="display: none;">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <polygon points="12,2 22,8.5 22,15.5 12,22 2,15.5 2,8.5" stroke-width="2"/>
                            </svg>
                            Polygon
                        </button>
                        <button class="tool-btn" data-tool="count" style="display: none;">
                            <svg fill="currentColor" viewBox="0 0 24 24">
                                <circle cx="12" cy="12" r="3"/>
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
                            </svg>
                            Count
                        </button>
                        <button class="tool-btn" data-tool="auto" style="display: none;">
                            <svg fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10-4.48 10-10S17.52,2 12,2zM12,20c-4.41,0 -8-3.59 -8-8s3.59-8 8-8 8,3.59 8,8 -3.59,8 -8,8zM16.59,7.58L10,14.17l-2.59-2.58L6,13l4,4 8-8z"/>
                            </svg>
                            Auto
                        </button>
                    </div>
                </div>

                <!-- Height Control -->
                <div class="section" id="heightControlSection" style="display: none;">
                    <div class="compact-control" onclick="changeRoomHeight()">
                        <svg class="compact-control-icon" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M7,2V4H17V2H19V5H20V7H19V22H17V20H7V22H5V7H4V5H5V2H7M7,7V18H17V7H7Z"/>
                        </svg>
                        <div class="compact-control-value" id="currentHeightDisplay">${state.currentCeilingHeight}m</div>
                    </div>
                </div>

                <!-- Aquacheck Controls -->
                <div class="section" id="aquacheckSection" style="display: none;">
                    <div style="position: relative;">
                        <div class="compact-control" onclick="toggleAquacheckPopup()">
                            <svg class="compact-control-icon" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M12,20A6,6 0 0,1 6,14C6,10 12,3.25 12,3.25S18,10 18,14A6,6 0 0,1 12,20Z"/>
                            </svg>
                            <span class="compact-control-value">Aquacheck</span>
                        </div>
                        <div class="aquacheck-popup" id="aquacheckPopup">
                            <div class="aquacheck-option">
                                <input type="checkbox" id="aquacheckWalls" onchange="updateAquacheck()">
                                <label for="aquacheckWalls">Walls</label>
                            </div>
                            <div class="aquacheck-option">
                                <input type="checkbox" id="aquacheckCeilings" onchange="updateAquacheck()">
                                <label for="aquacheckCeilings">Ceilings</label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Count Style (hidden by default) -->
                <div class="section" id="countStyleSection" style="display: none;">
                    <!-- Count style moved to Items editor -->
                </div>

                <!-- Item Types -->
                <div class="section" id="itemTypeSection" style="display: none;">
                    <div class="section-title">Item Type</div>
                    <div id="itemCategories"></div>
                </div>

                <!-- Polygon Options -->
                <div class="section" id="polygonOptionsSection" style="display: none;">
                    <div class="section-title">Wall Type</div>
                    <div id="wallTypeCategories"></div>
                    <div class="wall-segments-list" id="wallSegmentsList"></div>
                </div>
            </div>
        </div>

        <!-- Canvas Container -->
        <div class="canvas-container">
            <div class="loading" id="loading" style="display: none;">Loading PDF...</div>
            <canvas id="pdfCanvas"></canvas>
            <canvas id="drawingCanvas"></canvas>
            
            <!-- Page Selector -->
            <div class="page-selector collapsed" id="pageSelector">
                <button class="page-selector-toggle" onclick="togglePageSelector()">
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M3,3H21V5H3V3M3,7H21V9H3V7M3,11H21V13H3V11M3,15H21V17H3V15M3,19H21V21H3V19Z"/>
                    </svg>
                </button>
                <div class="page-list" id="pageList">
                    <!-- Pages will be added here -->
                </div>
            </div>
            
            <!-- Action Controls -->
            <div class="action-controls">
                <button class="action-btn" id="undoBtn" title="Undo (Ctrl+Z)" disabled>
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M12.5,8C9.85,8 7.45,9 5.6,10.6L2,7V16H11L7.38,12.38C8.77,11.22 10.54,10.5 12.5,10.5C16.04,10.5 19.05,12.81 20.1,16L22.47,15.22C21.08,11.03 17.15,8 12.5,8Z"/>
                    </svg>
                    <span class="tooltip">Undo</span>
                </button>
                <button class="icon-btn" onclick="openStyleDialog()">
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z"/>
                    </svg>
                    <span class="tooltip">Drawing Style</span>
                </button>
                <button class="icon-btn" onclick="openItemsEditor()">
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
                    </svg>
                    <span class="tooltip">Items</span>
                </button>
                <button class="icon-btn" onclick="toggleHouseInfo()">
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M10,20V14H14V20H19V12H22L12,3L2,12H5V20H10Z"/>
                    </svg>
                    <span class="tooltip">House Info</span>
                </button>
                <button class="icon-btn" onclick="openBillingWindow()">
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M7,15H9C9,16.08 10.37,17 12,17C13.63,17 15,16.08 15,15C15,13.9 13.96,13.5 11.76,12.97C9.64,12.44 7,11.78 7,9C7,7.21 8.47,5.69 10.5,5.18V3H13.5V5.18C15.53,5.69 17,7.21 17,9H15C15,7.92 13.63,7 12,7C10.37,7 9,7.92 9,9C9,10.1 10.04,10.5 12.24,11.03C14.36,11.56 17,12.22 17,15C17,16.79 15.53,18.31 13.5,18.82V21H10.5V18.82C8.47,18.31 7,16.79 7,15Z"/>
                    </svg>
                    <span class="tooltip">Billing</span>
                </button>
                <button class="icon-btn" onclick="openEstimateWindow()">
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19M12,7V9H10V11H12V13H10V15H12V17H14V15H16V13H14V11H16V9H14V7H12Z"/>
                    </svg>
                    <span class="tooltip">Create Estimate</span>
                </button>
                <button class="icon-btn" onclick="openProfileDialog()">
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M12,4A4,4 0 0,1 16,8A4,4 0 0,1 12,12A4,4 0 0,1 8,8A4,4 0 0,1 12,4M12,14C16.42,14 20,15.79 20,18V20H4V18C4,15.79 7.58,14 12,14Z"/>
                    </svg>
                    <span class="tooltip">Profiles</span>
                </button>
                <div class="current-selection" id="currentSelection" style="display: none;">
                    <span class="selection-label">Selected:</span>
                    <div class="item-color" id="selectionColor"></div>
                    <select id="selectionDropdown" onchange="changeSelectedItem(this.value)" style="background: #1a1a1a; border: 1px solid #333; color: #fff; font-size: 13px; cursor: pointer; padding: 4px 8px; border-radius: 4px;">
                        <!-- Options will be populated dynamically -->
                    </select>
                </div>
                <div class="finish-selector">
                    <label>Finish:</label>
                    <select id="mainFinishSelect" onchange="updateMainFinish()">
                        <!-- Will be populated -->
                    </select>
                </div>
            </div>
            
            <!-- Drawing Style Dialog -->
            <div class="style-dialog" id="styleDialog">
                <h4>Drawing Style</h4>
                <div>
                    <label style="font-size: 12px; color: #999;">Line Width</label>
                    <div class="line-width-options">
                        <div class="line-width-option active" onclick="selectLineWidth(1)" data-width="1">
                            <div class="line-preview" style="height: 1px;"></div>
                        </div>
                        <div class="line-width-option" onclick="selectLineWidth(2)" data-width="2">
                            <div class="line-preview" style="height: 2px;"></div>
                        </div>
                        <div class="line-width-option" onclick="selectLineWidth(3)" data-width="3">
                            <div class="line-preview" style="height: 3px;"></div>
                        </div>
                        <div class="line-width-option" onclick="selectLineWidth(5)" data-width="5">
                            <div class="line-preview" style="height: 5px;"></div>
                        </div>
                        <div class="line-width-option" onclick="selectLineWidth(8)" data-width="8">
                            <div class="line-preview" style="height: 8px;"></div>
                        </div>
                    </div>
                </div>
                <div class="opacity-control">
                    <label style="font-size: 12px; color: #999;">Opacity</label>
                    <div class="opacity-preview" id="opacityPreview"></div>
                    <input type="range" class="opacity-slider" id="opacitySlider" min="10" max="100" value="30" onchange="updateOpacity(this.value)">
                    <div style="text-align: center; font-size: 11px; color: #00d4ff; margin-top: 5px;">
                        <span id="opacityValue">30%</span>
                    </div>
                </div>
            </div>
            
            <!-- House Info Panel -->
            <div class="house-info" id="houseInfoPanel">
                <h4>
                    House Information
                    <button class="close-house-info" onclick="toggleHouseInfo()">×</button>
                </h4>
                <div class="info-row">
                    <label>Ceiling Height (m)</label>
                    <input type="number" id="globalCeilingHeight" value="2.4" step="0.1" min="2.0" max="4.0" onchange="updateGlobalCeilingHeight()">
                </div>
                <div class="info-row">
                    <label>Framing Direction</label>
                    <select id="globalFramingDirection" onchange="updateFramingDirection()">
                        <option value="vertical">Vertical</option>
                        <option value="horizontal">Horizontal</option>
                    </select>
                </div>
                <div class="info-row">
                    <label>Wall Type</label>
                    <select id="globalWallType" onchange="updateWallType()">
                        <option value="timber">Timber</option>
                        <option value="brick">Brick</option>
                    </select>
                </div>
                <div class="info-row">
                    <label>Finish</label>
                    <select id="globalFinish" onchange="updateGlobalFinish()">
                        <!-- Will be populated with cornice options -->
                    </select>
                </div>
            </div>

            <!-- Zoom Controls -->
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomOut">
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M19,13H5V11H19V13Z"/>
                    </svg>
                </button>
                <button class="zoom-btn" id="zoomIn">
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z"/>
                    </svg>
                </button>
                <button class="zoom-btn" id="zoomReset">
                    <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M10,16.5L16,12L10,7.5V16.5Z"/>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Right Panel - Measurements -->
        <div class="right-panel" id="rightPanel">
            <div class="panel-header">
                <h3>Measurements</h3>
                <button class="panel-toggle" onclick="togglePanel()">◀</button>
            </div>
            <div class="panel-content">
                <div id="measurementsList"></div>
            </div>
        </div>
    </div>

    <!-- Scale Dialog -->
    <div class="modal-overlay" id="scaleDialog" style="display: none;">
        <div class="scale-dialog">
            <h3>Set Scale</h3>
            
            <div class="dialog-section">
                <label>What is the real-world length of the line you drew?</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="number" id="scaleLengthInput" value="1" step="0.001" min="0.001" style="flex: 1;">
                    <span>meters</span>
                </div>
                <p style="font-size: 12px; color: #999; margin-top: 8px;">
                    Tip: You can enter millimeters (e.g., 4200) and it will be converted to meters (4.2m)
                </p>
            </div>
            
            <div class="scale-dialog-buttons">
                <button class="confirm-btn" onclick="confirmScale()">OK</button>
                <button class="cancel-btn" onclick="cancelScale()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Room Name Dialog -->
    <div class="room-name-dialog" id="roomNameDialog" style="display: none;">
        <div class="dialog-header" id="roomNameHeader">
            <h3 style="margin: 0; color: #00d4ff; font-size: 16px;">Enter Room Name</h3>
            <button class="close-btn" onclick="cancelRoomName()" style="margin: 0;">×</button>
        </div>
        <input type="text" id="roomNameInput" placeholder="Room name...">
        <div class="scale-dialog-buttons">
            <button class="confirm-btn" onclick="confirmRoomName()">OK</button>
            <button class="cancel-btn" onclick="cancelRoomName()">Cancel</button>
        </div>
    </div>

    <!-- Height Change Dialog -->
    <div class="room-name-dialog" id="heightChangeDialog" style="display: none;">
        <div class="dialog-header">
            <h3 style="margin: 0; color: #00d4ff; font-size: 16px;">Change Ceiling Height</h3>
            <button class="close-btn" onclick="cancelHeightChange()" style="margin: 0;">×</button>
        </div>
        <input type="number" id="roomHeightInput" value="2.4" step="0.1" min="2.0" max="4.0">
        <div class="scale-dialog-buttons">
            <button class="confirm-btn" onclick="confirmHeightChange()">OK</button>
            <button class="cancel-btn" onclick="cancelHeightChange()">Cancel</button>
        </div>
    </div>

    <!-- Reminder Dialog -->
    <div class="reminder-dialog" id="reminderDialog" style="display: none;">
        <h3>Missing Items Reminder</h3>
        <div id="reminderContent"></div>
        <div class="reminder-buttons">
            <button class="reminder-continue" onclick="continueEstimate()">Continue Anyway</button>
            <button class="reminder-cancel" onclick="closeReminderDialog()">Go Back</button>
        </div>
    </div>

    <!-- Openings Dialog -->
    <div class="openings-dialog" id="openingsDialog" style="display: none;">
        <h3>Enter Openings Area</h3>
        <input type="number" id="openingsInput" placeholder="Enter m² of openings" step="0.01" min="0">
        <div class="scale-dialog-buttons">
            <button class="confirm-btn" onclick="applyOpenings()">Apply</button>
            <button class="cancel-btn" onclick="closeOpeningsDialog()">Cancel</button>
        </div>
    </div>

    <!-- Profile Dialog -->
    <div class="room-name-dialog" id="profileDialog" style="display: none;">
        <div class="dialog-header">
            <h3 style="margin: 0; color: #00d4ff; font-size: 16px;">Select Profile</h3>
            <button class="close-btn" onclick="closeProfileDialog()" style="margin: 0;">×</button>
        </div>
        <select id="profileSelect" style="width: 100%; margin-bottom: 15px; padding: 10px; background: #1a1a1a; border: 1px solid #444; border-radius: 4px; color: #fff;">
            <!-- Options will be populated -->
        </select>
        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
            <button class="confirm-btn" style="flex: 1;" onclick="addProfile()">Add New</button>
            <button class="confirm-btn" style="flex: 1;" onclick="renameProfile()">Rename</button>
        </div>
        <div class="scale-dialog-buttons">
            <button class="confirm-btn" onclick="selectProfile()">Select</button>
            <button class="cancel-btn" onclick="closeProfileDialog()">Cancel</button>
        </div>
    </div>

    <!-- Billing Window -->
    <div class="billing-window" id="billingWindow" style="display: none;">
        <div class="billing-header">
            <h3>Billing - <span id="billingPageName">Current Page</span></h3>
            <button class="close-btn" onclick="closeBillingWindow()">×</button>
        </div>
        <div class="billing-content">
            <table class="billing-table">
                <thead>
                    <tr>
                        <th style="width: 35%;">Item Name</th>
                        <th style="width: 20%;">Quantity</th>
                        <th style="width: 20%;">Price</th>
                        <th style="width: 25%;">Total</th>
                    </tr>
                </thead>
                <tbody id="billingTableBody">
                    <!-- Billing rows will be added here -->
                </tbody>
            </table>
            <div class="billing-totals">
                <div class="billing-total-row">
                    <span>Subtotal:</span>
                    <span>$<span id="billingSubtotal">0.00</span></span>
                </div>
                <div class="billing-total-row">
                    <span>GST (10%):</span>
                    <span>$<span id="billingGST">0.00</span></span>
                </div>
                <div class="billing-total-row grand-total">
                    <span>Total (inc. GST):</span>
                    <span>$<span id="billingGrandTotal">0.00</span></span>
                </div>
            </div>
        </div>
    </div>

    <!-- Estimate Window -->
    <div class="estimate-window" id="estimateWindow" style="display: none;">
        <div class="estimate-header">
            <h2>Complete Estimate</h2>
            <button class="close-btn" onclick="closeEstimateWindow()">×</button>
        </div>
        <div class="estimate-content" id="estimateContent">
            <!-- Estimate sections will be added here -->
        </div>
    </div>

    <!-- Items Editor -->
    <div class="items-editor-overlay" id="itemsEditor" style="display: none;">
        <div class="items-editor">
            <div class="items-editor-header">
                <h3>Edit Items</h3>
                <button class="export-pdf-btn" onclick="exportPriceList()">
                    <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
                    </svg>
                    Export Price List
                </button>
                <button class="close-btn" onclick="closeItemsEditor()">×</button>
            </div>
            <div class="items-editor-content" id="itemsEditorContent">
                <div class="profile-editor">
                    <label>Current Profile:</label>
                    <select id="editorProfileDropdown" onchange="switchProfileInEditor()">
                        <!-- Options will be populated -->
                    </select>
                    <button onclick="saveCurrentProfile()">Save Profile</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Default Item Types - Complete list from PDFs
        const defaultItemTypes = {
            "Ceilings": [
                { id: "ceiling_101", name: "Fix, Flush to Timber Batten", color: "#D4A76A", unit: "m2", price: 35.00 },
                { id: "ceiling_102", name: "Bg05 Clip, Fix, Flush", color: "#87CEEB", unit: "m2", price: 65.00 },
                { id: "ceiling_103", name: "226 Clip, Fix, Flush", color: "#87CEEB", unit: "m2", price: 65.00 },
                { id: "ceiling_104", name: "Suspended Ceiling, Fix, Flush", color: "#DDA0DD", unit: "m2", price: 90.00 },
                { id: "ceiling_105", name: "Square Tape Finish", color: "#FFD700", unit: "m", price: 25.00 },
                { id: "ceiling_106", name: "P50", color: "#FF6B6B", unit: "m", price: 30.00 },
                { id: "ceiling_107", name: "Cove Cornice", color: "#FFD700", unit: "m", price: 20.00 },
                { id: "ceiling_108", name: "Cornice - Aria Symphony ect", color: "#FFD700", unit: "m", price: 27.50 },
                { id: "ceiling_109", name: "Cornice - 3 Step", color: "#FFD700", unit: "m", price: 35.00 },
                { id: "ceiling_110", name: "L Beam Bulkhead", color: "#6BCF7F", unit: "m", price: 100.00 },
                { id: "ceiling_111", name: "U Beam Bulkhead", color: "#6BCF7F", unit: "m", price: 200.00 },
                { id: "ceiling_112", name: "Curved Bulkhead Per Curve", color: "#DDA0DD", unit: "m", price: 400.00 },
                { id: "ceiling_113", name: "Light Trough Perimeter", color: "#DDA0DD", unit: "m", price: 120.00 },
                { id: "ceiling_114", name: "Curtain Pelmet MDF Only", color: "#90EE90", unit: "m", price: 115.00 },
                { id: "ceiling_115", name: "Curtain Pelmet MDF + Plasterboard line", color: "#90EE90", unit: "m", price: 250.00 },
                { id: "ceiling_116", name: "Exangle Bead LM", color: "#4A90E2", unit: "m", price: 30.00 },
                { id: "ceiling_117", name: "Exangle Bead 2.7m Length", color: "#4A90E2", unit: "Count", price: 60.00 },
                { id: "ceiling_118", name: "Aluminium Manhole", color: "#2F4F4F", unit: "Count", price: 100.00 },
                { id: "ceiling_119", name: "Flush in Access Panel", color: "#808080", unit: "Count", price: 250.00 },
                { id: "ceiling_120", name: "Soffits", color: "#2F4F4F", unit: "Count", price: 80.00 },
                { id: "ceiling_121", name: "Aquacheck Board Allowance", color: "#87CEEB", unit: "m2", price: 15.00 },
                { id: "ceiling_122", name: "13mm Fix, Flush to Timber Batten", color: "#90EE90", unit: "m2", price: 45.00 },
                { id: "ceiling_123", name: "13mm Soundcheck Fix, Flush to Timber", color: "#90EE90", unit: "m2", price: 55.00 },
                { id: "ceiling_124", name: "Raking Ceiling Extra Allowance (Up to 3)", color: "#FFA07A", unit: "m2", price: 35.00 },
                { id: "ceiling_125", name: "Raking Ceilings Extra Allowance 13m - 4", color: "#FFA07A", unit: "m2", price: 70.00 },
                { id: "ceiling_126", name: "Ceiling Rose", color: "#9370DB", unit: "Count", price: 450.00 },
                { id: "ceiling_127", name: "Cornice - Medium Colonial", color: "#DC143C", unit: "m", price: 110.00 },
                { id: "ceiling_128", name: "Cornice To FHT", color: "#4169E1", unit: "Count", price: 350.00 },
                { id: "ceiling_129", name: "R4 Insulation", color: "#D4A76A", unit: "m2", price: 20.00 },
                { id: "ceiling_130", name: "Skylight", color: "#32CD32", unit: "Count", price: 600.00 },
                { id: "ceiling_131", name: "Flexi Tape / 45 Bead", color: "#FFD700", unit: "m", price: 80.00 }
            ],
            "Walls": [
                { id: "wall_201", name: "R2 Insulation", color: "#D4A76A", unit: "m", price: 20.00 },
                { id: "wall_202", name: "R2.5 HD Insulation", color: "#D4A76A", unit: "m", price: 25.00 },
                { id: "wall_203", name: "Fix, Flush Wall To Timber Batten 1 Side", color: "#6BCF7F", unit: "m2", price: 35.00 },
                { id: "wall_204", name: "Fix, Flush Wall To Timber Batten (2 Side)", color: "#6BCF7F", unit: "m2", price: 70.00 },
                { id: "wall_205", name: "Exangle Bead LM", color: "#4A90E2", unit: "m", price: 30.00 },
                { id: "wall_206", name: "Exangle Bead 2.7m Length", color: "#4A90E2", unit: "Count", price: 80.00 },
                { id: "wall_207", name: "P10 Stopping Bead", color: "#FF8C69", unit: "m", price: 30.00 },
                { id: "wall_208", name: "Reveal Bead LM (Thick Gauge)", color: "#DA70D6", unit: "m", price: 45.00 },
                { id: "wall_209", name: "Reveal Bead 2.7 Length (Thick Gauge)", color: "#DA70D6", unit: "Count", price: 100.00 },
                { id: "wall_210", name: "13mm Fix, Flush Wall to Timber (1 Side)", color: "#556B2F", unit: "m2", price: 45.00 },
                { id: "wall_211", name: "13mm Fix, Flush Wall to Timber (2 Sides)", color: "#556B2F", unit: "m2", price: 90.00 },
                { id: "wall_212", name: "P50 to Skirtings / Doorframes LM", color: "#FF8C00", unit: "m", price: 45.00 },
                { id: "wall_213", name: "Stud + Track Frame Only", color: "#DDA0DD", unit: "m2", price: 55.00 },
                { id: "wall_214", name: "Door", color: "#696969", unit: "Count", price: 0.00 },
                { id: "wall_215", name: "Openings", color: "#DC143C", unit: "m2", price: 0.00 },
                { id: "wall_216", name: "Aquacheck Board Allowance", color: "#87CEEB", unit: "m", price: 15.00 },
                { id: "wall_217", name: "Drywall", color: "#DC143C", unit: "m2", price: 55.00 }
            ]
        };

        // App State
        const state = {
            currentTool: 'move',
            pdfDoc: null,
            pages: [
                {
                    name: 'Page 1',
                    pageNum: 1,
                    scale: null,
                    pixelsPerMeter: 100,
                    measurements: [],
                    viewport: null
                }
            ],
            currentPageIndex: 0,
            baseScale: 3,
            zoom: 1,
            isDrawing: false,
            isPanning: false,
            startPoint: null,
            currentPath: [],
            currentLineSegments: [],
            panOffset: { x: 0, y: 0 },
            lastPanPoint: null,
            tempScaleLine: null,
            hoveredMeasurement: null,
            hoveredSegment: null,
            selectedItemType: null,
            selectedWallType: null,
            itemTypes: JSON.parse(JSON.stringify(defaultItemTypes)),
            undoStack: [],
            maxUndoLevels: 10,
            editingGroup: null,
            lineCounter: 1,
            lineWidth: 2,
            opacity: 30,
            collapsedGroups: new Set(),
            visibleGroups: new Set(),
            pdfTextItems: [],
            currentPolygonSegments: [],
            pendingPolygonData: null,
            countShape: 'circle',
            countSize: 20,
            countColor: '#00d4ff',
            globalCeilingHeight: 2.4,
            currentCeilingHeight: 2.4, // Track current height for new measurements
            framingDirection: 'vertical',
            wallType: 'timber',
            globalFinish: null,
            currentFinish: null, // Track finish for new items only
            aquacheckWalls: false,
            aquacheckCeilings: false,
            currentAquacheckWalls: false, // Track aquacheck for new items only
            currentAquacheckCeilings: false, // Track aquacheck for new items only
            isDraggingBilling: false,
            billingDragOffset: { x: 0, y: 0 },
            isDraggingEstimate: false,
            estimateDragOffset: { x: 0, y: 0 },
            isDraggingRoomName: false,
            roomNameDragOffset: { x: 0, y: 0 },
            selectedRoom: null, // For openings
            profiles: {
                default: JSON.parse(JSON.stringify(defaultItemTypes))
            },
            currentProfile: 'default'
        };

        // DOM Elements
        const pdfCanvas = document.getElementById('pdfCanvas');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const drawCtx = drawingCanvas.getContext('2d');

        // Initialize
        function init() {
            setupEventListeners();
            updateMeasurementsList();
            renderItemTypes(false, null);
            populateFinishOptions();
            populateWallTypeOptions(false);
            updateOpacityPreview();
            loadProfiles();
        }

        // Setup Event Listeners
        function setupEventListeners() {
            // Tool Selection
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', selectTool);
            });

            // Canvas Events
            drawingCanvas.addEventListener('mousedown', startDrawing);
            drawingCanvas.addEventListener('mousemove', draw);
            drawingCanvas.addEventListener('mouseup', endDrawing);
            drawingCanvas.addEventListener('mouseleave', endDrawing);
            drawingCanvas.addEventListener('dblclick', handleDoubleClick);
            drawingCanvas.addEventListener('wheel', handleWheel);

            // PDF Upload
            document.getElementById('pdfUpload').addEventListener('change', handlePDFUpload);

            // Zoom Controls
            document.getElementById('zoomIn').addEventListener('click', () => adjustZoom(1.2));
            document.getElementById('zoomOut').addEventListener('click', () => adjustZoom(1/1.2));
            document.getElementById('zoomReset').addEventListener('click', resetZoom);

            // Undo
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                    e.preventDefault();
                    undo();
                }
            });

            // Scale Dialog
            document.getElementById('scaleLengthInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') confirmScale();
            });

            // Room Name Dialog
            document.getElementById('roomNameInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') confirmRoomName();
            });
            
            // Auto-capitalize first letter
            document.getElementById('roomNameInput').addEventListener('input', (e) => {
                const input = e.target;
                if (input.value.length === 1) {
                    input.value = input.value.toUpperCase();
                }
            });
            
            // Room Name Dialog dragging
            const roomNameHeader = document.getElementById('roomNameHeader');
            if (roomNameHeader) {
                roomNameHeader.addEventListener('mousedown', startDragRoomName);
            }

            // Click outside to close style dialog
            document.addEventListener('click', (e) => {
                const styleDialog = document.getElementById('styleDialog');
                const pencilBtn = e.target.closest('.icon-btn[onclick*="openStyleDialog"]');
                if (!styleDialog.contains(e.target) && !pencilBtn) {
                    styleDialog.classList.remove('show');
                }
            });

            // Billing window dragging
            const billingHeader = document.querySelector('.billing-header');
            if (billingHeader) {
                billingHeader.addEventListener('mousedown', startDragBilling);
            }

            // Estimate window dragging
            const estimateHeader = document.querySelector('.estimate-header');
            if (estimateHeader) {
                estimateHeader.addEventListener('mousedown', startDragEstimate);
            }
        }

        // Page Management
        function togglePageSelector() {
            const selector = document.getElementById('pageSelector');
            selector.classList.toggle('collapsed');
            selector.classList.toggle('expanded');
            
            if (selector.classList.contains('expanded')) {
                updatePageList();
            }
        }

        function updatePageList() {
            const pageList = document.getElementById('pageList');
            pageList.innerHTML = '';
            
            state.pages.forEach((page, index) => {
                const pageItem = document.createElement('div');
                pageItem.className = 'page-item' + (index === state.currentPageIndex ? ' active' : '');
                
                // Create thumbnail container
                const thumbnailDiv = document.createElement('div');
                thumbnailDiv.className = 'page-thumbnail';
                thumbnailDiv.id = `thumbnail-${index}`;
                thumbnailDiv.textContent = 'Loading...';
                
                // Add measurement indicator
                const hasMeasurements = page.measurements.length > 0;
                const measurementIndicator = hasMeasurements ? 
                    '<div style="position: absolute; bottom: 2px; right: 2px; width: 8px; height: 8px; background: #00d4ff; border-radius: 50%;"></div>' : '';
                
                pageItem.innerHTML = `
                    <div class="page-thumbnail" style="position: relative;">
                        ${thumbnailDiv.outerHTML}
                        ${measurementIndicator}
                    </div>
                    <input type="text" class="page-name" value="${page.name}" 
                           onchange="renamePage(${index}, this.value)" 
                           onclick="event.stopPropagation()"
                           style="background: transparent; border: none; color: #00d4ff; font-weight: 600; text-align: center; font-size: 12px; width: 100%;">
                    <div style="font-size: 11px; color: #666;">${page.measurements.length} measurements</div>
                `;
                pageItem.onclick = (e) => {
                    if (e.target.tagName !== 'INPUT') {
                        switchToPage(index);
                    }
                };
                pageList.appendChild(pageItem);

                // Render thumbnail with delay to avoid blocking
                setTimeout(() => renderPageThumbnail(index), index * 100);
            });
        }

        async function renderPageThumbnail(pageIndex) {
            if (!state.pdfDoc) return;
            
            const page = await state.pdfDoc.getPage(state.pages[pageIndex].pageNum);
            const viewport = page.getViewport({ scale: 0.2 }); // Lower scale for performance
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            
            const renderContext = {
                canvasContext: ctx,
                viewport: viewport
            };
            
            await page.render(renderContext).promise;
            
            // Insert canvas into thumbnail div
            const thumbnailDiv = document.getElementById(`thumbnail-${pageIndex}`);
            if (thumbnailDiv) {
                thumbnailDiv.innerHTML = '';
                thumbnailDiv.appendChild(canvas);
            }
        }
        
        function renamePage(pageIndex, newName) {
            if (newName.trim()) {
                state.pages[pageIndex].name = newName.trim();
                updatePageList();
            }
        }

        function switchToPage(pageIndex) {
            if (pageIndex === state.currentPageIndex) return;
            
            state.currentPageIndex = pageIndex;
            
            // Reset zoom and pan for new page to fit screen
            const containerRect = document.querySelector('.canvas-container').getBoundingClientRect();
            const currentPage = getCurrentPage();
            if (currentPage.viewport) {
                const scaleX = (containerRect.width * 0.8) / currentPage.viewport.width;
                const scaleY = (containerRect.height * 0.8) / currentPage.viewport.height;
                state.zoom = Math.min(scaleX, scaleY);
            } else {
                state.zoom = 1;
            }
            state.panOffset = { x: 0, y: 0 };
            
            if (state.pdfDoc) {
                renderPage();
            }
            
            updatePageList();
            updateMeasurementsList();
            document.getElementById('pageSelector').classList.remove('expanded');
            document.getElementById('pageSelector').classList.add('collapsed');
        }

        // Current Page Getters
        function getCurrentPage() {
            return state.pages[state.currentPageIndex];
        }

        function getCurrentMeasurements() {
            return getCurrentPage().measurements;
        }

        function getCurrentScale() {
            return getCurrentPage().scale;
        }

        function getCurrentPixelsPerMeter() {
            return getCurrentPage().pixelsPerMeter;
        }

        // Tool Selection
        function selectTool(e) {
            const tool = e.currentTarget.dataset.tool;
            
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            e.currentTarget.classList.add('active');
            state.currentTool = tool;
            
            drawingCanvas.style.cursor = tool === 'move' ? 'grab' : 'crosshair';
            
            // Show/hide relevant sections
            document.getElementById('polygonOptionsSection').style.display = 
                tool === 'polygon' && state.wallType === 'timber' ? 'block' : 'none';
                
            // Filter items based on selected tool
            if (tool === 'polygon' || tool === 'auto') {
                renderItemTypes(false, 'polygon'); // Show only specific ceiling items for polygon/auto
            } else if (tool === 'count') {
                renderItemTypes(true); // Show only count items
            } else if (tool === 'line') {
                renderItemTypes(false, 'line'); // Show all items for line tool
            } else {
                renderItemTypes(false); // Show all items
            }
            
            // Update wall type options based on tool
            if ((tool === 'polygon' || tool === 'auto') && state.wallType === 'timber') {
                populateWallTypeOptions(true); // Show only specific wall types
            } else {
                populateWallTypeOptions(false); // Show all wall types
            }
        }

        // Scale Tool Selection
        function selectScaleTool() {
            const scaleBtn = document.querySelector('[data-tool="scale"]');
            if (!scaleBtn) {
                // If scale button is not in tools, create temporary one
                state.currentTool = 'scale';
                drawingCanvas.style.cursor = 'crosshair';
            } else {
                scaleBtn.click();
            }
        }

        // Drawing Style
        function openStyleDialog() {
            const dialog = document.getElementById('styleDialog');
            dialog.classList.toggle('show');
            updateOpacityPreview();
        }

        function selectLineWidth(width) {
            state.lineWidth = width;
            document.querySelectorAll('.line-width-option').forEach(opt => {
                opt.classList.remove('active');
            });
            document.querySelector(`.line-width-option[data-width="${width}"]`).classList.add('active');
        }

        function updateOpacity(value) {
            state.opacity = parseInt(value);
            document.getElementById('opacityValue').textContent = `${value}%`;
            updateOpacityPreview();
        }

        function updateOpacityPreview() {
            const preview = document.getElementById('opacityPreview');
            const color = state.selectedItemType ? state.selectedItemType.color : '#00d4ff';
            preview.style.backgroundColor = hexToRgba(color, state.opacity / 100);
        }

        // Count Shape Selection
        function selectCountShape(shape) {
            state.countShape = shape;
            document.querySelectorAll('.shape-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            saveProfiles(); // Save preference
        }

        function updateCountSize(value) {
            state.countSize = parseInt(value);
            // Update display if in items editor
            const sizeDisplay = document.querySelector('#countSizeEditor + div');
            if (sizeDisplay) {
                sizeDisplay.textContent = `${value}px`;
            }
            saveProfiles(); // Save preference
        }

        function updateCountColor(value) {
            state.countColor = value;
            saveProfiles(); // Save preference
        }

        // Aquacheck popup toggle
        function toggleAquacheckPopup() {
            const popup = document.getElementById('aquacheckPopup');
            popup.classList.toggle('show');
            
            // Close on click outside
            if (popup.classList.contains('show')) {
                setTimeout(() => {
                    document.addEventListener('click', closeAquacheckPopup);
                }, 100);
            }
        }

        function closeAquacheckPopup(e) {
            const popup = document.getElementById('aquacheckPopup');
            const control = popup.parentElement.querySelector('.compact-control');
            if (!popup.contains(e.target) && !control.contains(e.target)) {
                popup.classList.remove('show');
                document.removeEventListener('click', closeAquacheckPopup);
            }
        }

        // Aquacheck Controls
        function updateAquacheck() {
            // Update current state for new items only
            state.currentAquacheckWalls = document.getElementById('aquacheckWalls').checked;
            state.currentAquacheckCeilings = document.getElementById('aquacheckCeilings').checked;
            
            // Don't update existing measurements - only affect new ones
            redrawMeasurements();
        }

        // House Info Toggle
        function toggleHouseInfo() {
            const panel = document.getElementById('houseInfoPanel');
            panel.classList.toggle('show');
        }

        // Update Current Selection Display
        function updateSelectionDisplay() {
            const display = document.getElementById('currentSelection');
            const colorDiv = document.getElementById('selectionColor');
            const dropdown = document.getElementById('selectionDropdown');
            
            if (state.selectedItemType) {
                display.style.display = 'flex';
                colorDiv.style.backgroundColor = state.selectedItemType.color;
                
                // Populate dropdown with items from same category
                const category = state.selectedItemType.id.startsWith('ceiling_') ? 'Ceilings' : 'Walls';
                const categoryPrefix = category === 'Ceilings' ? 'Ceilings: ' : 'Walls: ';
                
                dropdown.innerHTML = '';
                state.itemTypes[category].forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.id;
                    option.textContent = categoryPrefix + item.name;
                    option.selected = item.id === state.selectedItemType.id;
                    dropdown.appendChild(option);
                });
            } else {
                display.style.display = 'none';
            }
        }
        
        // Change Selected Item from Dropdown
        function changeSelectedItem(itemId) {
            const allItems = [...state.itemTypes.Ceilings, ...state.itemTypes.Walls];
            const newItem = allItems.find(item => item.id === itemId);
            if (newItem) {
                state.selectedItemType = newItem;
                updateSelectionDisplay();
                updateOpacityPreview();
            }
        }

        // Global Controls
        function updateGlobalCeilingHeight() {
            const height = parseFloat(document.getElementById('globalCeilingHeight').value);
            state.globalCeilingHeight = height;
            state.currentCeilingHeight = height; // Update current height
            document.getElementById('currentHeightDisplay').textContent = height + 'm';
            
            // Update all wall measurements
            getCurrentMeasurements().forEach(m => {
                if (m.wallType && m.type === 'polygon') {
                    m.wallHeight = height;
                }
            });
            
            updateMeasurementsList();
            updateBillingData();
        }

        function updateFramingDirection() {
            state.framingDirection = document.getElementById('globalFramingDirection').value;
        }

        function updateWallType() {
            state.wallType = document.getElementById('globalWallType').value;
            
            // Hide/show polygon wall type based on global wall type
            if (state.currentTool === 'polygon') {
                document.getElementById('polygonOptionsSection').style.display = 
                    state.wallType === 'timber' ? 'block' : 'none';
            }
            
            updateBillingData();
        }

        function updateGlobalFinish() {
            const finishId = document.getElementById('globalFinish').value;
            state.currentFinish = finishId ? 
                state.itemTypes.Ceilings.find(i => i.id === finishId) : null;
            
            // Sync both selects
            document.getElementById('globalFinish').value = finishId;
            document.getElementById('mainFinishSelect').value = finishId;
            
            // Don't update existing measurements - only affect new ones
            redrawMeasurements();
        }

        function updateMainFinish() {
            const finishId = document.getElementById('mainFinishSelect').value;
            state.currentFinish = finishId ? 
                state.itemTypes.Ceilings.find(i => i.id === finishId) : null;
            
            // Don't sync with global finish - this is independent
            // Don't update existing measurements - only affect new ones
            redrawMeasurements();
        }

        // Height Change
        function changeRoomHeight() {
            const dialog = document.getElementById('heightChangeDialog');
            document.getElementById('roomHeightInput').value = state.currentCeilingHeight;
            dialog.style.display = 'block';
            dialog.style.left = '50%';
            dialog.style.top = '50%';
            dialog.style.transform = 'translate(-50%, -50%)';
        }

        function confirmHeightChange() {
            const newHeight = parseFloat(document.getElementById('roomHeightInput').value);
            state.currentCeilingHeight = newHeight;
            document.getElementById('currentHeightDisplay').textContent = newHeight + 'm';
            document.getElementById('heightChangeDialog').style.display = 'none';
        }

        function cancelHeightChange() {
            document.getElementById('heightChangeDialog').style.display = 'none';
        }

        // Openings
        function openOpeningsDialog() {
            if (state.wallType !== 'timber') {
                alert('Openings can only be applied to Timber wall types.');
                return;
            }
            
            state.currentTool = 'openings';
            state.selectedRoom = null;
        }

        function closeOpeningsDialog() {
            document.getElementById('openingsDialog').style.display = 'none';
            state.selectedRoom = null;
            state.currentTool = 'move';
        }

        function applyOpenings() {
            const openingsArea = parseFloat(document.getElementById('openingsInput').value);
            if (!openingsArea || openingsArea <= 0 || !state.selectedRoom) {
                alert('Please enter a valid openings area.');
                return;
            }
            
            // Apply openings deduction to the selected room
            state.selectedRoom.openingsArea = openingsArea;
            
            closeOpeningsDialog();
            updateMeasurementsList();
            updateBillingData();
        }

        // Populate Options
        function populateFinishOptions() {
            const selects = [document.getElementById('globalFinish'), document.getElementById('mainFinishSelect')];
            
            selects.forEach(select => {
                select.innerHTML = '<option value="">None</option>';
                
                // Add cornice options and other finish items
                state.itemTypes.Ceilings.forEach(item => {
                    if (item.name.toLowerCase().includes('cornice') || 
                        item.name === 'Square Tape Finish' || 
                        item.name === 'P50') {
                        const option = document.createElement('option');
                        option.value = item.id;
                        option.textContent = item.name;
                        select.appendChild(option);
                    }
                });
            });
        }

        function populateWallTypeOptions(polygonOnly = false) {
            const container = document.getElementById('wallTypeCategories');
            if (!container) return;
            
            container.innerHTML = '';
            
            // Define allowed wall items for polygon mode
            const polygonWallItems = [
                'wall_203', // Fix, Flush Wall To Timber Batten 1 Side
                'wall_210'  // 13mm Fix, Flush Wall to Timber (1 Side)
            ];
            
            // Create category div
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'item-category';
            
            const header = document.createElement('div');
            header.className = 'category-header';
            header.innerHTML = `
                <span>Wall Types</span>
                <span class="category-arrow open">▶</span>
            `;
            header.onclick = () => toggleCategory('WallTypes');
            
            const itemsDiv = document.createElement('div');
            itemsDiv.className = 'category-items open';
            itemsDiv.id = 'category-WallTypes';
            
            // Add wall items
            state.itemTypes.Walls.forEach(item => {
                if (item.unit === 'm2') {
                    // Filter based on mode
                    if (polygonOnly && !polygonWallItems.includes(item.id)) {
                        return; // Skip this item in polygon mode
                    }
                    
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'item-option';
                    itemDiv.innerHTML = `
                        <div class="item-color" style="background-color: ${item.color}"></div>
                        <span>${item.name}</span>
                    `;
                    itemDiv.onclick = () => selectWallType(item);
                    
                    if (state.selectedWallType && state.selectedWallType.id === item.id) {
                        itemDiv.classList.add('selected');
                    }
                    
                    itemsDiv.appendChild(itemDiv);
                }
            });
            
            categoryDiv.appendChild(header);
            categoryDiv.appendChild(itemsDiv);
            container.appendChild(categoryDiv);
            
            // Set default selection
            if (!state.selectedWallType && itemsDiv.children.length > 0) {
                const firstItem = itemsDiv.children[0];
                firstItem.click();
            }
        }

        function selectWallType(item) {
            state.selectedWallType = item;
            populateWallTypeOptions(true);
        }

        // Update Polygon Wall Type
        function updatePolygonWallType() {
            const select = document.getElementById('polygonWallType');
            state.selectedWallType = state.itemTypes.Walls.find(i => i.id === select.value);
        }

        // PDF Upload
        function handlePDFUpload(e) {
            const file = e.target.files[0];
            if (file && file.type === 'application/pdf') {
                loadPDF(file);
            }
        }

        async function loadPDF(file) {
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            
            const fileReader = new FileReader();
            fileReader.onload = async function() {
                const typedarray = new Uint8Array(this.result);
                
                try {
                    state.pdfDoc = await pdfjsLib.getDocument(typedarray).promise;
                    
                    // Initialize pages
                    state.pages = [];
                    for (let i = 1; i <= state.pdfDoc.numPages; i++) {
                        state.pages.push({
                            name: `Page ${i}`,
                            pageNum: i,
                            scale: null,
                            pixelsPerMeter: 100,
                            measurements: [],
                            viewport: null
                        });
                    }
                    
                    state.currentPageIndex = 0;
                    
                    await renderPage();
                    
                    // Show page selector if multiple pages
                    if (state.pdfDoc.numPages > 1) {
                        document.getElementById('pageSelector').style.display = 'block';
                    }
                    
                    // Show house info panel for new PDF
                    document.getElementById('houseInfoPanel').classList.add('show');
                    
                    if (!getCurrentScale()) {
                        setTimeout(() => {
                            alert('PDF loaded! Please use the "Set Scale" tool to calibrate measurements.');
                        }, 500);
                    }
                } catch (error) {
                    console.error('Error loading PDF:', error);
                    alert('Error loading PDF. Please try another file.');
                } finally {
                    loading.style.display = 'none';
                }
            };
            fileReader.readAsArrayBuffer(file);
        }

        async function renderPage() {
            const currentPage = getCurrentPage();
            const page = await state.pdfDoc.getPage(currentPage.pageNum);
            currentPage.viewport = page.getViewport({ scale: state.baseScale });
            
            const outputScale = window.devicePixelRatio || 1;
            
            pdfCanvas.width = Math.floor(currentPage.viewport.width * outputScale);
            pdfCanvas.height = Math.floor(currentPage.viewport.height * outputScale);
            drawingCanvas.width = Math.floor(currentPage.viewport.width * outputScale);
            drawingCanvas.height = Math.floor(currentPage.viewport.height * outputScale);
            
            pdfCanvas.style.width = Math.floor(currentPage.viewport.width) + 'px';
            pdfCanvas.style.height = Math.floor(currentPage.viewport.height) + 'px';
            drawingCanvas.style.width = Math.floor(currentPage.viewport.width) + 'px';
            drawingCanvas.style.height = Math.floor(currentPage.viewport.height) + 'px';
            
            // Fit to screen if this is the first render
            if (state.zoom === 1 && state.panOffset.x === 0 && state.panOffset.y === 0) {
                const containerRect = document.querySelector('.canvas-container').getBoundingClientRect();
                const scaleX = (containerRect.width * 0.8) / currentPage.viewport.width;
                const scaleY = (containerRect.height * 0.8) / currentPage.viewport.height;
                state.zoom = Math.min(scaleX, scaleY);
            }
            
            // Apply transform to canvases
            const transform = `translate(calc(-50% + ${state.panOffset.x}px), calc(-50% + ${state.panOffset.y}px)) scale(${state.zoom})`;
            pdfCanvas.style.transform = transform;
            drawingCanvas.style.transform = transform;
            
            const renderContext = {
                canvasContext: pdfCtx,
                viewport: currentPage.viewport,
                transform: outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null
            };
            
            await page.render(renderContext).promise;
            
            // Extract text for room detection
            const textContent = await page.getTextContent();
            state.pdfTextItems = textContent.items.map(item => ({
                text: item.str,
                x: item.transform[4] * state.baseScale,
                y: (currentPage.viewport.height - item.transform[5] * state.baseScale),
                width: item.width * state.baseScale,
                height: item.height * state.baseScale,
                fontSize: Math.sqrt(item.transform[0] * item.transform[0] + item.transform[1] * item.transform[1])
            }));
            
            redrawMeasurements();
        }

        // Mouse Wheel Zoom
        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            adjustZoom(delta);
        }

        // Get Canvas Coordinates
        function getCanvasCoordinates(e) {
            const rect = drawingCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - rect.width/2) / state.zoom + drawingCanvas.width/2;
            const y = (e.clientY - rect.top - rect.height/2) / state.zoom + drawingCanvas.height/2;
            return { x, y };
        }

        // Drawing Functions
        function startDrawing(e) {
            // Don't allow drawing if any dialog is open
            if (document.getElementById('roomNameDialog').style.display === 'block' ||
                document.getElementById('scaleDialog').style.display === 'flex' ||
                document.getElementById('heightChangeDialog').style.display === 'block' ||
                document.getElementById('openingsDialog').style.display === 'block') {
                return;
            }
            
            if (state.currentTool === 'move') {
                state.isPanning = true;
                state.lastPanPoint = { x: e.clientX, y: e.clientY };
                drawingCanvas.style.cursor = 'grabbing';
                return;
            }
            
            if (state.currentTool === 'openings') {
                const coords = getCanvasCoordinates(e);
                checkRoomClick(coords.x, coords.y);
                return;
            }
            
            const coords = getCanvasCoordinates(e);
            if (state.currentTool === 'auto') {
                // Try to auto-detect room boundaries
                const detectedRoom = detectRoomBoundaries(coords);
                if (detectedRoom && detectedRoom.length >= 3) {
                    // Create segments from detected points
                    const segments = [];
                    for (let i = 0; i < detectedRoom.length; i++) {
                        const start = detectedRoom[i];
                        const end = detectedRoom[(i + 1) % detectedRoom.length];
                        segments.push({
                            start: start,
                            end: end,
                            length: calculateDistance(start, end) / getCurrentPixelsPerMeter()
                        });
                    }
                    
                    // Store polygon data
                    state.pendingPolygonData = {
                        type: 'polygon',
                        points: detectedRoom,
                        segments: segments,
                        wallType: state.selectedWallType
                    };
                    
                    // Draw preview
                    drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    redrawMeasurements();
                    
                    const itemType = getSelectedItemType();
                    const color = itemType ? itemType.color : '#00d4ff';
                    
                    drawCtx.strokeStyle = color;
                    drawCtx.lineWidth = state.lineWidth;
                    drawCtx.fillStyle = hexToRgba(color, state.opacity / 100);
                    
                    drawCtx.beginPath();
                    drawCtx.moveTo(detectedRoom[0].x, detectedRoom[0].y);
                    detectedRoom.forEach(p => drawCtx.lineTo(p.x, p.y));
                    drawCtx.closePath();
                    drawCtx.stroke();
                    drawCtx.fill();
                    
                    // Show room name dialog
                    setTimeout(() => {
                        const dialog = document.getElementById('roomNameDialog');
                        dialog.style.display = 'block';
                        dialog.style.left = '50%';
                        dialog.style.top = '50%';
                        dialog.style.transform = 'translate(-50%, -50%)';
                        
                        const input = document.getElementById('roomNameInput');
                        input.value = detectRoomName(detectedRoom) || 'Room';
                        input.select();
                        input.focus();
                    }, 100);
                } else {
                    alert('Could not detect room boundaries. Please use the polygon tool for manual drawing.');
                }
                return;
            }
            
            const x = coords.x;
            const y = coords.y;
            
            if (state.currentTool === 'line') {
                if (!state.isDrawing) {
                    state.isDrawing = true;
                    state.currentLineSegments = [];
                    state.startPoint = { x, y };
                } else {
                    // Add segment to current line chain
                    state.currentLineSegments.push({
                        start: state.startPoint,
                        end: { x, y }
                    });
                    state.startPoint = { x, y };
                }
            } else if (state.currentTool === 'polygon') {
                if (!state.isDrawing) {
                    state.isDrawing = true;
                    state.currentPath = [{ x, y }];
                    state.currentPolygonSegments = [];
                } else {
                    // Record segment for wall calculation
                    const lastPoint = state.currentPath[state.currentPath.length - 1];
                    state.currentPolygonSegments.push({
                        start: lastPoint,
                        end: { x, y },
                        length: calculateDistance(lastPoint, { x, y }) / getCurrentPixelsPerMeter()
                    });
                    state.currentPath.push({ x, y });
                    updateWallSegmentsList();
                }
            } else if (state.currentTool === 'count') {
                // Place count marker immediately
                if (state.selectedItemType && state.selectedItemType.unit === 'Count') {
                    saveMeasurement({
                        type: 'count',
                        point: { x, y },
                        groupName: state.selectedItemType.name,
                        shape: state.countShape,
                        size: state.countSize,
                        markerColor: state.countColor
                    });
                }
            } else if (state.currentTool === 'scale') {
                state.isDrawing = true;
                state.startPoint = { x, y };
            }
        }

        function checkRoomClick(x, y) {
            getCurrentMeasurements().forEach(m => {
                if (m.type === 'polygon' && isPointInPolygon({ x, y }, m.points)) {
                    state.selectedRoom = m;
                    document.getElementById('openingsDialog').style.display = 'block';
                    document.getElementById('openingsInput').value = m.openingsArea || '';
                    document.getElementById('openingsInput').focus();
                }
            });
        }

        function updateWallSegmentsList() {
            const container = document.getElementById('wallSegmentsList');
            if (state.currentPolygonSegments.length === 0) {
                container.innerHTML = '';
                return;
            }
            
            let html = '<div style="margin-top: 8px; font-size: 11px;">';
            html += '<div style="color: #00d4ff; margin-bottom: 4px;">Wall Segments:</div>';
            state.currentPolygonSegments.forEach((seg, i) => {
                html += `<div class="wall-segment">Wall ${i + 1}: ${seg.length.toFixed(2)}m</div>`;
            });
            const totalLength = state.currentPolygonSegments.reduce((sum, seg) => sum + seg.length, 0);
            html += `<div style="margin-top: 4px; color: #00d4ff;">Total: ${totalLength.toFixed(2)}m</div>`;
            html += '</div>';
            container.innerHTML = html;
        }

        function draw(e) {
            const coords = getCanvasCoordinates(e);
            const x = coords.x;
            const y = coords.y;
            
            if (state.currentTool === 'move' && !state.isPanning) {
                checkMeasurementHover(x, y);
            }
            
            if (state.isPanning && state.currentTool === 'move') {
                const dx = e.clientX - state.lastPanPoint.x;
                const dy = e.clientY - state.lastPanPoint.y;
                
                state.panOffset.x += dx;
                state.panOffset.y += dy;
                
                const transform = `translate(calc(-50% + ${state.panOffset.x}px), calc(-50% + ${state.panOffset.y}px)) scale(${state.zoom})`;
                pdfCanvas.style.transform = transform;
                drawingCanvas.style.transform = transform;
                
                state.lastPanPoint = { x: e.clientX, y: e.clientY };
                return;
            }
            
            if (!state.isDrawing || state.currentTool === 'count') return;
            
            drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            redrawMeasurements();
            
            const itemType = getSelectedItemType();
            const color = itemType ? itemType.color : '#00d4ff';
            
            drawCtx.strokeStyle = color;
            drawCtx.lineWidth = state.lineWidth;
            drawCtx.fillStyle = hexToRgba(color, state.opacity / 100);
            
            if (state.currentTool === 'line') {
                // Draw completed segments
                state.currentLineSegments.forEach(seg => {
                    drawCtx.beginPath();
                    drawCtx.moveTo(seg.start.x, seg.start.y);
                    drawCtx.lineTo(seg.end.x, seg.end.y);
                    drawCtx.stroke();
                });
                
                // Draw current segment
                drawCtx.beginPath();
                drawCtx.moveTo(state.startPoint.x, state.startPoint.y);
                drawCtx.lineTo(x, y);
                drawCtx.stroke();
                
                const currentDist = calculateDistance(state.startPoint, { x, y });
                const totalDist = state.currentLineSegments.reduce((sum, seg) => 
                    sum + calculateDistance(seg.start, seg.end), 0) + currentDist;
                const meters = (totalDist / getCurrentPixelsPerMeter()).toFixed(2);
                drawMeasurementLabel(state.startPoint, { x, y }, `${meters}m`, true);
                
            } else if (state.currentTool === 'scale') {
                drawCtx.beginPath();
                drawCtx.moveTo(state.startPoint.x, state.startPoint.y);
                drawCtx.lineTo(x, y);
                drawCtx.stroke();
                
            } else if (state.currentTool === 'polygon') {
                drawCtx.beginPath();
                drawCtx.moveTo(state.currentPath[0].x, state.currentPath[0].y);
                state.currentPath.forEach(point => {
                    drawCtx.lineTo(point.x, point.y);
                });
                drawCtx.lineTo(x, y);
                drawCtx.stroke();
                
                state.currentPath.forEach(point => {
                    drawCtx.beginPath();
                    drawCtx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
                    drawCtx.fill();
                });
                
                // Show current segment length
                if (state.currentPath.length > 0) {
                    const lastPoint = state.currentPath[state.currentPath.length - 1];
                    const currentLength = calculateDistance(lastPoint, { x, y }) / getCurrentPixelsPerMeter();
                    drawMeasurementLabel(lastPoint, { x, y }, `${currentLength.toFixed(2)}m`, true);
                }
            }
        }

        function endDrawing(e) {
            if (state.isPanning) {
                state.isPanning = false;
                drawingCanvas.style.cursor = state.currentTool === 'move' ? 'grab' : 'crosshair';
                return;
            }
            
            if (!state.isDrawing) return;
            
            const coords = getCanvasCoordinates(e);
            const x = coords.x;
            const y = coords.y;
            
            if (state.currentTool === 'scale') {
                state.tempScaleLine = {
                    start: state.startPoint,
                    end: { x, y },
                    distance: calculateDistance(state.startPoint, { x, y })
                };
                
                document.getElementById('scaleDialog').style.display = 'flex';
                const input = document.getElementById('scaleLengthInput');
                input.focus();
                input.select();
                
                state.isDrawing = false;
            }
        }

        function handleDoubleClick(e) {
            if (state.currentTool === 'polygon' && state.currentPath.length >= 3) {
                // Don't add the final segment from double-click
                // Just close the polygon with existing points
                const firstPoint = state.currentPath[0];
                const lastPoint = state.currentPath[state.currentPath.length - 1];
                
                // Only add closing segment if points are different
                if (firstPoint.x !== lastPoint.x || firstPoint.y !== lastPoint.y) {
                    state.currentPolygonSegments.push({
                        start: lastPoint,
                        end: firstPoint,
                        length: calculateDistance(lastPoint, firstPoint) / getCurrentPixelsPerMeter()
                    });
                }
                
                // Store polygon data temporarily
                state.pendingPolygonData = {
                    type: 'polygon',
                    points: [...state.currentPath],
                    segments: [...state.currentPolygonSegments],
                    wallType: state.selectedWallType
                };
                
                // Stop drawing immediately
                state.isDrawing = false;
                drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                redrawMeasurements();
                
                // Show room name dialog
                const dialog = document.getElementById('roomNameDialog');
                dialog.style.display = 'block';
                dialog.style.left = '50%';
                dialog.style.top = '50%';
                dialog.style.transform = 'translate(-50%, -50%)';
                
                const input = document.getElementById('roomNameInput');
                const detectedName = detectRoomName(state.currentPath) || 'Room';
                // Auto-capitalize first letter
                input.value = detectedName.charAt(0).toUpperCase() + detectedName.slice(1);
                input.select();
                input.focus();
                
            } else if (state.currentTool === 'line' && state.currentLineSegments.length > 0) {
                finishLineChain();
            }
        }

        function confirmRoomName() {
            const roomName = document.getElementById('roomNameInput').value || 'Room';
            document.getElementById('roomNameDialog').style.display = 'none';
            
            if (state.pendingPolygonData) {
                saveMeasurement({
                    ...state.pendingPolygonData,
                    groupName: roomName
                });
                
                state.currentPath = [];
                state.currentPolygonSegments = [];
                state.isDrawing = false;
                state.pendingPolygonData = null;
                document.getElementById('wallSegmentsList').innerHTML = '';
                drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                redrawMeasurements();
            }
        }

        function cancelRoomName() {
            document.getElementById('roomNameDialog').style.display = 'none';
            state.pendingPolygonData = null;
            
            state.currentPath = [];
            state.currentPolygonSegments = [];
            state.isDrawing = false;
            state.pendingPolygonData = null;
            document.getElementById('wallSegmentsList').innerHTML = '';
            drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            redrawMeasurements();
        }

        function detectRoomName(polygonPoints) {
            if (!state.pdfTextItems || state.pdfTextItems.length === 0) return null;
            
            // Find text items within polygon
            const textInPolygon = state.pdfTextItems.filter(item => {
                const centerX = item.x + item.width / 2;
                const centerY = item.y + item.height / 2;
                return isPointInPolygon({ x: centerX, y: centerY }, polygonPoints);
            });
            
            if (textInPolygon.length === 0) return null;
            
            // Find the largest text item (by font size)
            const largestText = textInPolygon.reduce((largest, item) => {
                return item.fontSize > largest.fontSize ? item : largest;
            });
            
            return largestText.text;
        }

        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > point.y) !== (yj > point.y))
                    && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function finishLineChain() {
            if (state.currentLineSegments.length === 0) return;
            
            const lineName = `Line ${state.lineCounter++}`;
            saveMeasurement({
                type: 'line-chain',
                segments: [...state.currentLineSegments],
                groupName: lineName
            });
            
            state.currentLineSegments = [];
            state.isDrawing = false;
            drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            redrawMeasurements();
        }

        // Save Measurement
        function saveMeasurement(data) {
            const itemType = getSelectedItemType();
            if (!itemType) {
                alert('Please select an item type first!');
                return;
            }
            
            const measurement = {
                id: Date.now(),
                ...data,
                itemType: itemType,
                lineWidth: state.lineWidth,
                opacity: state.opacity,
                timestamp: new Date().toISOString(),
                visible: true,
                // Store current aquacheck and finish settings with this measurement
                hasAquacheckWalls: state.currentAquacheckWalls,
                hasAquacheckCeilings: state.currentAquacheckCeilings,
                appliedFinish: state.currentFinish ? {...state.currentFinish} : null,
                // Store current ceiling height
                ceilingHeight: state.currentCeilingHeight
            };
            
            // Calculate values based on type
            if (data.type === 'line-chain') {
                measurement.length = data.segments.reduce((sum, seg) => 
                    sum + calculateDistance(seg.start, seg.end), 0) / getCurrentPixelsPerMeter();
                if (itemType.unit === 'm' && itemType.id.includes('wall')) {
                    measurement.height = state.currentCeilingHeight; // Use current height
                }
            } else if (data.type === 'polygon') {
                measurement.area = calculatePolygonArea(data.points) / (getCurrentPixelsPerMeter() * getCurrentPixelsPerMeter());
                measurement.wallHeight = state.currentCeilingHeight; // Use current height
                measurement.perimeter = data.segments.reduce((sum, seg) => sum + seg.length, 0);
            } else if (data.type === 'count') {
                measurement.count = 1;
            }
            
            // Add to undo stack
            state.undoStack.push({
                action: 'add',
                measurement: measurement,
                pageIndex: state.currentPageIndex
            });
            if (state.undoStack.length > state.maxUndoLevels) {
                state.undoStack.shift();
            }
            updateUndoButton();
            
            getCurrentMeasurements().push(measurement);
            
            // Add to visible groups
            state.visibleGroups.add(measurement.itemType.id);
            
            updateMeasurementsList();
            updateBillingData();
            redrawMeasurements();
        }

        // Measurement Hover
        function checkMeasurementHover(x, y) {
            let foundHover = false;
            let foundSegmentHover = null;
            
            getCurrentMeasurements().forEach((m, index) => {
                if (m.type === 'line-chain') {
                    m.segments.forEach((seg, segIndex) => {
                        const dist = distanceToLine(seg.start, seg.end, { x, y });
                        if (dist < 10) {
                            state.hoveredMeasurement = index;
                            foundSegmentHover = segIndex;
                            foundHover = true;
                            drawingCanvas.style.cursor = 'pointer';
                        }
                    });
                } else if (m.type === 'polygon') {
                    // Check for hover on individual segments
                    let foundSegment = false;
                    if (m.segments) {
                        m.segments.forEach((seg, segIndex) => {
                            const dist = distanceToLine(seg.start, seg.end, { x, y });
                            if (dist < 10) {
                                state.hoveredMeasurement = index;
                                foundSegmentHover = segIndex;
                                foundHover = true;
                                foundSegment = true;
                                drawingCanvas.style.cursor = 'pointer';
                            }
                        });
                    }
                    
                    // If not hovering on segment, check if inside polygon
                    if (!foundSegment) {
                        const inside = isPointInPolygon({ x, y }, m.points);
                        if (inside) {
                            state.hoveredMeasurement = index;
                            foundHover = true;
                            drawingCanvas.style.cursor = 'pointer';
                        }
                    }
                } else if (m.type === 'count') {
                    const dist = calculateDistance(m.point, { x, y });
                    if (dist < m.size / 2 + 5) {
                        state.hoveredMeasurement = index;
                        foundHover = true;
                        drawingCanvas.style.cursor = 'pointer';
                    }
                }
            });
            
            if (!foundHover && state.hoveredMeasurement !== null) {
                state.hoveredMeasurement = null;
                state.hoveredSegment = null;
                drawingCanvas.style.cursor = 'grab';
                updateMeasurementsList();
            }
            
            if (foundHover || state.hoveredMeasurement !== null) {
                state.hoveredSegment = foundSegmentHover;
                updateMeasurementsList();
                redrawMeasurements();
            }
        }

        // Measurement List Hover
        function handleMeasurementHover(measurementId, isHover) {
            const measurements = getCurrentMeasurements();
            const index = measurements.findIndex(m => m.id === measurementId);
            if (index !== -1) {
                state.hoveredMeasurement = isHover ? index : null;
                redrawMeasurements();
                updateMeasurementsList();
            }
        }

        function handleSegmentHover(measurementId, segmentIndex, isHover) {
            const measurements = getCurrentMeasurements();
            const index = measurements.findIndex(m => m.id === measurementId);
            if (index !== -1) {
                state.hoveredMeasurement = isHover ? index : null;
                state.hoveredSegment = isHover ? segmentIndex : null;
                redrawMeasurements();
                updateMeasurementsList();
            }
        }

        // Scale Confirmation
        function confirmScale() {
            let length = parseFloat(document.getElementById('scaleLengthInput').value);
            
            // Convert mm to m if value is greater than 100
            if (length > 100) {
                length = length / 1000;
            }
            
            if (length > 0 && state.tempScaleLine) {
                const currentPage = getCurrentPage();
                currentPage.pixelsPerMeter = state.tempScaleLine.distance / length;
                currentPage.scale = true;
                
                document.getElementById('scaleDialog').style.display = 'none';
                
                // Show all hidden tool buttons
                document.querySelectorAll('.tool-btn[style*="display: none"]').forEach(btn => {
                    btn.style.display = 'block';
                });
                
                document.getElementById('itemTypeSection').style.display = 'block';
                document.getElementById('aquacheckSection').style.display = 'block';
                document.getElementById('heightControlSection').style.display = 'block';
                
                document.querySelector('[data-tool="polygon"]').click();
                
                // Clear any drawing state
                state.isDrawing = false;
                state.currentPath = [];
                state.currentPolygonSegments = [];
                state.currentLineSegments = [];
                drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                state.tempScaleLine = null;
            }
        }

        function cancelScale() {
            document.getElementById('scaleDialog').style.display = 'none';
            state.tempScaleLine = null;
            drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            redrawMeasurements();
        }

        // Group Name Editing
        function editGroupName(groupKey) {
            state.editingGroup = groupKey;
            updateMeasurementsList();
        }

        function saveGroupName(groupKey, newName) {
            getCurrentMeasurements().forEach(m => {
                if (m.groupName === groupKey) {
                    m.groupName = newName;
                }
            });
            state.editingGroup = null;
            updateMeasurementsList();
        }

        // Visibility Toggle
        function toggleGroupVisibility(groupKey) {
            if (state.visibleGroups.has(groupKey)) {
                state.visibleGroups.delete(groupKey);
            } else {
                state.visibleGroups.add(groupKey);
            }
            
            // Update measurement visibility
            getCurrentMeasurements().forEach(m => {
                if (m.itemType.id === groupKey) {
                    m.visible = state.visibleGroups.has(groupKey);
                }
            });
            
            updateMeasurementsList();
            redrawMeasurements();
        }

        // Delete Functions
        function deleteGroup(groupKey) {
            if (confirm(`Delete all measurements in this group?`)) {
                const toDelete = getCurrentMeasurements().filter(m => m.itemType.id === groupKey);
                toDelete.forEach(m => {
                    state.undoStack.push({
                        action: 'delete',
                        measurement: m,
                        pageIndex: state.currentPageIndex
                    });
                });
                
                const currentPage = getCurrentPage();
                currentPage.measurements = currentPage.measurements.filter(m => m.itemType.id !== groupKey);
                
                updateUndoButton();
                updateMeasurementsList();
                updateBillingData();
                redrawMeasurements();
            }
        }

        function deleteMeasurement(measurementId) {
            const measurements = getCurrentMeasurements();
            const measurement = measurements.find(m => m.id === measurementId);
            if (measurement) {
                state.undoStack.push({
                    action: 'delete',
                    measurement: measurement,
                    pageIndex: state.currentPageIndex
                });
                updateUndoButton();
                
                const currentPage = getCurrentPage();
                currentPage.measurements = currentPage.measurements.filter(m => m.id !== measurementId);
                
                updateMeasurementsList();
                updateBillingData();
                redrawMeasurements();
            }
        }

        // Undo
        function undo() {
            if (state.undoStack.length === 0) return;
            
            const lastAction = state.undoStack.pop();
            const page = state.pages[lastAction.pageIndex];
            
            if (lastAction.action === 'add') {
                page.measurements = page.measurements.filter(m => m.id !== lastAction.measurement.id);
            } else if (lastAction.action === 'delete') {
                page.measurements.push(lastAction.measurement);
            }
            
            updateUndoButton();
            updateMeasurementsList();
            updateBillingData();
            redrawMeasurements();
        }

        function updateUndoButton() {
            document.getElementById('undoBtn').disabled = state.undoStack.length === 0;
        }

        // Item Types
        function renderItemTypes(countOnly = false, toolMode = null) {
            const container = document.getElementById('itemCategories');
            container.innerHTML = '';
            
            // Define allowed ceiling items for polygon mode
            const polygonCeilingItems = [
                'ceiling_101', // Fix, Flush to Timber Batten
                'ceiling_102', // Bg05 Clip, Fix, Flush
                'ceiling_103', // 226 Clip, Fix, Flush
                'ceiling_104'  // Suspended Ceiling, Fix, Flush
            ];
            
            Object.entries(state.itemTypes).forEach(([category, items]) => {
                let filteredItems = items;
                
                if (countOnly) {
                    filteredItems = items.filter(item => item.unit === 'Count');
                    if (filteredItems.length === 0) return;
                } else if (toolMode === 'polygon') {
                    // For polygon tool, only show specific ceiling items, hide walls
                    if (category === 'Ceilings') {
                        filteredItems = items.filter(item => polygonCeilingItems.includes(item.id));
                    } else if (category === 'Walls') {
                        return; // Hide walls completely in polygon mode
                    }
                } else if (toolMode === 'line') {
                    // For line tool, show all items (no filtering)
                    filteredItems = items;
                }
                
                if (filteredItems.length === 0) return;
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'item-category';
                
                const header = document.createElement('div');
                header.className = 'category-header';
                header.innerHTML = `
                    <span>${category}</span>
                    <span class="category-arrow">▶</span>
                `;
                header.onclick = () => toggleCategory(category);
                
                const itemsDiv = document.createElement('div');
                itemsDiv.className = 'category-items';
                itemsDiv.id = `category-${category}`;
                
                filteredItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'item-option';
                    itemDiv.innerHTML = `
                        <div class="item-color" style="background-color: ${item.color}"></div>
                        <span>${item.name}</span>
                    `;
                    itemDiv.onclick = () => selectItemType(item);
                    
                    if (state.selectedItemType && state.selectedItemType.id === item.id) {
                        itemDiv.classList.add('selected');
                    }
                    
                    itemsDiv.appendChild(itemDiv);
                });
                
                categoryDiv.appendChild(header);
                categoryDiv.appendChild(itemsDiv);
                container.appendChild(categoryDiv);
            });
        }

        function toggleCategory(category) {
            const itemsDiv = document.getElementById(`category-${category}`);
            const arrow = itemsDiv.previousElementSibling.querySelector('.category-arrow');
            
            itemsDiv.classList.toggle('open');
            arrow.classList.toggle('open');
        }

        function selectItemType(item) {
            state.selectedItemType = item;
            renderItemTypes(state.currentTool === 'count', state.currentTool);
            updateSelectionDisplay();
            updateOpacityPreview();
        }

        function getSelectedItemType() {
            return state.selectedItemType;
        }

        // Items Editor
        function openItemsEditor() {
            renderItemsEditor();
            document.getElementById('itemsEditor').style.display = 'flex';
        }

        function closeItemsEditor() {
            document.getElementById('itemsEditor').style.display = 'none';
            renderItemTypes(state.currentTool === 'count', state.currentTool);
            updateMeasurementsList();
            updateBillingData();
            populateFinishOptions();
            populateWallTypeOptions(state.currentTool === 'polygon');
            saveProfiles();
        }

        function renderItemsEditor() {
            const container = document.getElementById('itemsEditorContent');
            
            // Profile editor section
            let profileHtml = `
                <div class="profile-editor">
                    <label>Current Profile:</label>
                    <select id="editorProfileDropdown" onchange="switchProfileInEditor()">
            `;
            
            Object.keys(state.profiles).forEach(profile => {
                profileHtml += `<option value="${profile}" ${profile === state.currentProfile ? 'selected' : ''}>${profile}</option>`;
            });
            
            profileHtml += `
                    </select>
                    <button onclick="saveCurrentProfile()">Save Profile</button>
                    <button onclick="addProfileInEditor()">Add New Profile</button>
                </div>
                
                <!-- Count Marker Settings -->
                <div class="items-category" style="background: #1a1a1a; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
                    <h4>Count Marker Settings</h4>
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 12px; color: #999;">Default Shape</label>
                        <div class="shape-selector">
                            <button class="shape-btn ${state.countShape === 'circle' ? 'active' : ''}" onclick="selectCountShape('circle')">○</button>
                            <button class="shape-btn ${state.countShape === 'square' ? 'active' : ''}" onclick="selectCountShape('square')">□</button>
                            <button class="shape-btn ${state.countShape === 'triangle' ? 'active' : ''}" onclick="selectCountShape('triangle')">△</button>
                            <button class="shape-btn ${state.countShape === 'diamond' ? 'active' : ''}" onclick="selectCountShape('diamond')">◇</button>
                            <button class="shape-btn ${state.countShape === 'cross' ? 'active' : ''}" onclick="selectCountShape('cross')">✕</button>
                        </div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 12px; color: #999;">Default Size</label>
                        <input type="range" id="countSizeEditor" min="10" max="40" value="${state.countSize}" onchange="updateCountSize(this.value)" style="width: 100%;">
                        <div style="text-align: center; font-size: 11px; color: #00d4ff;">${state.countSize}px</div>
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #999;">Default Color</label>
                        <input type="color" id="countColorEditor" value="${state.countColor}" onchange="updateCountColor(this.value)" style="width: 100%; height: 30px;">
                    </div>
                </div>
            `;
            
            container.innerHTML = profileHtml;
            
            // Item categories
            Object.entries(state.itemTypes).forEach(([category, items]) => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'items-category';
                categoryDiv.innerHTML = `
                    <h4>${category}</h4>
                    <button class="add-item-btn" onclick="addNewItem('${category}')">Add New Item</button>
                `;
                
                const itemsContainer = document.createElement('div');
                items.forEach((item, index) => {
                    const row = document.createElement('div');
                    row.className = 'item-row';
                    row.innerHTML = `
                        <input type="color" value="${item.color}" onchange="updateItemColor('${category}', ${index}, this.value)">
                        <input type="text" value="${item.name}" onchange="updateItemName('${category}', ${index}, this.value)">
                        <select onchange="updateItemUnit('${category}', ${index}, this.value)">
                            <option value="m" ${item.unit === 'm' ? 'selected' : ''}>m</option>
                            <option value="m2" ${item.unit === 'm2' ? 'selected' : ''}>m²</option>
                            <option value="Count" ${item.unit === 'Count' ? 'selected' : ''}>Count</option>
                        </select>
                        <input type="number" value="${item.price}" step="0.01" onchange="updateItemPrice('${category}', ${index}, this.value)">
                        <button class="delete-item-btn" onclick="deleteItem('${category}', ${index})">×</button>
                    `;
                    itemsContainer.appendChild(row);
                });
                
                categoryDiv.appendChild(itemsContainer);
                container.appendChild(categoryDiv);
            });
        }

        function addProfileInEditor() {
            const name = prompt('Enter new profile name:');
            if (name && !state.profiles[name]) {
                state.profiles[name] = JSON.parse(JSON.stringify(defaultItemTypes));
                saveProfiles();
                renderItemsEditor();
                alert(`Profile "${name}" created successfully!`);
            }
        }

        function updateItemColor(category, index, color) {
            state.itemTypes[category][index].color = color;
        }

        function updateItemName(category, index, name) {
            state.itemTypes[category][index].name = name;
        }

        function updateItemUnit(category, index, unit) {
            state.itemTypes[category][index].unit = unit;
        }

        function updateItemPrice(category, index, price) {
            state.itemTypes[category][index].price = parseFloat(price);
        }

        function deleteItem(category, index) {
            if (confirm('Delete this item?')) {
                state.itemTypes[category].splice(index, 1);
                renderItemsEditor();
            }
        }

        function addNewItem(category) {
            const newId = `${category.toLowerCase().slice(0, -1)}_${Date.now()}`;
            const newItem = {
                id: newId,
                name: 'New Item',
                color: '#888888',
                unit: category === 'Ceilings' ? 'm2' : 'm',
                price: 0.00
            };
            state.itemTypes[category].push(newItem);
            renderItemsEditor();
        }

        // Measurements List
        function updateMeasurementsList() {
            const container = document.getElementById('measurementsList');
            container.innerHTML = '';
            
            const measurements = getCurrentMeasurements();
            
            if (measurements.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No measurements yet</p>';
                return;
            }
            
            // Group measurements by item type
            const grouped = {};
            measurements.forEach(m => {
                const key = m.itemType.id;
                if (!grouped[key]) {
                    grouped[key] = {
                        itemType: m.itemType,
                        measurements: []
                    };
                }
                grouped[key].measurements.push(m);
            });
            
            Object.entries(grouped).forEach(([key, group]) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'measurements-group';
                
                // Check if any measurement in group is hovered
                const hasHoveredMeasurement = group.measurements.some(m => {
                    const index = measurements.findIndex(measurement => measurement.id === m.id);
                    return index === state.hoveredMeasurement;
                });
                
                if (hasHoveredMeasurement) {
                    groupDiv.classList.add('highlighted');
                }
                
                const total = calculateGroupTotal(group.measurements, group.itemType);
                const isOpen = !state.collapsedGroups.has(key);
                const isVisible = state.visibleGroups.has(key);
                
                const header = document.createElement('div');
                header.className = 'group-header';
                
                let heightDisplay = '';
                if (group.itemType.unit === 'm' && group.itemType.id.includes('wall')) {
                    const heights = [...new Set(group.measurements.map(m => m.height || m.ceilingHeight || state.globalCeilingHeight))];
                    if (heights.length === 1) {
                        heightDisplay = ` × ${heights[0]}m height`;
                    } else {
                        heightDisplay = ` × various heights`;
                    }
                }
                
                header.innerHTML = `
                    <div class="group-info">
                        <span class="group-arrow ${isOpen ? 'open' : ''}">▶</span>
                        <div class="item-color" style="background-color: ${group.itemType.color}; width: 16px; height: 16px; border-radius: 3px;"></div>
                        <span class="group-name">${group.itemType.name}</span>
                    </div>
                    <div class="group-actions">
                        <span class="group-total">${formatValue(total, group.itemType.unit)}${heightDisplay}</span>
                        <button class="visibility-toggle ${isVisible ? 'visible' : ''}" onclick="toggleGroupVisibility('${key}')" title="${isVisible ? 'Hide' : 'Show'}">
                            ${isVisible ? '👁' : '👁‍🗨'}
                        </button>
                        <button class="group-delete" onclick="deleteGroup('${key}')">Delete</button>
                    </div>
                `;
                
                header.onclick = (e) => {
                    if (!e.target.classList.contains('visibility-toggle') && 
                        !e.target.classList.contains('group-delete') &&
                        !e.target.closest('.group-delete')) {
                        toggleGroupCollapse(key);
                    }
                };
                
                const itemsDiv = document.createElement('div');
                itemsDiv.className = `group-items ${isOpen ? 'open' : ''}`;
                
                // Group by room for polygons
                if (group.measurements[0].type === 'polygon') {
                    const byRoom = {};
                    group.measurements.forEach(m => {
                        if (!byRoom[m.groupName]) {
                            byRoom[m.groupName] = [];
                        }
                        byRoom[m.groupName].push(m);
                    });
                    
                    Object.entries(byRoom).forEach(([roomName, roomMeasurements]) => {
                        const roomGroup = createRoomGroup(roomName, roomMeasurements, measurements);
                        itemsDiv.appendChild(roomGroup);
                    });
                } else {
                    // Regular measurements
                    group.measurements.forEach(m => {
                        const item = createMeasurementItem(m, measurements);
                        itemsDiv.appendChild(item);
                    });
                }
                
                groupDiv.appendChild(header);
                groupDiv.appendChild(itemsDiv);
                container.appendChild(groupDiv);
            });
        }

        function createRoomGroup(roomName, roomMeasurements, allMeasurements) {
            const container = document.createElement('div');
            container.className = 'room-group';
            
            const measurement = roomMeasurements[0];
            const index = allMeasurements.findIndex(m => m.id === measurement.id);
            const isHovered = index === state.hoveredMeasurement;
            
            // Room header
            const roomHeader = document.createElement('div');
            roomHeader.className = 'room-header';
            if (isHovered) {
                roomHeader.classList.add('highlighted');
            }
            
            const isOpen = !state.collapsedGroups.has(`room-${measurement.id}`);
            
            roomHeader.innerHTML = `
                <span class="room-name">${roomName}</span>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span class="room-arrow ${isOpen ? 'open' : ''}">▼</span>
                    <button class="measurement-delete" onclick="deleteMeasurement(${measurement.id})" title="Delete">×</button>
                </div>
            `;
            
            roomHeader.onmouseenter = () => handleMeasurementHover(measurement.id, true);
            roomHeader.onmouseleave = () => handleMeasurementHover(measurement.id, false);
            
            const roomDetails = document.createElement('div');
            roomDetails.className = 'room-details';
            roomDetails.style.display = isOpen ? 'block' : 'none';
            
            // Room details
            const detailsHtml = `
                <div class="room-detail-item">
                    <span class="detail-label">Ceiling:</span>
                    <span class="detail-value">${measurement.itemType.name}</span>
                </div>
                <div class="room-detail-item">
                    <span class="detail-label">Area:</span>
                    <span class="detail-value">${measurement.area.toFixed(2)}m²</span>
                </div>
                ${measurement.wallType && state.wallType === 'timber' ? `
                <div class="room-detail-item">
                    <span class="detail-label">Walls:</span>
                    <span class="detail-value">${measurement.wallType.name}</span>
                </div>
                <div class="room-detail-item">
                    <span class="detail-label">Wall Area:</span>
                    <span class="detail-value">${(measurement.perimeter * measurement.wallHeight).toFixed(2)}m²</span>
                </div>
                ` : ''}
                ${measurement.appliedFinish ? `
                <div class="room-detail-item">
                    <span class="detail-label">Finish:</span>
                    <span class="detail-value">${measurement.appliedFinish.name}</span>
                </div>
                <div class="room-detail-item">
                    <span class="detail-label">Finish Length:</span>
                    <span class="detail-value">${measurement.perimeter.toFixed(2)}m</span>
                </div>
                ` : ''}
                ${measurement.hasAquacheckCeilings ? `
                <div class="room-detail-item">
                    <span class="detail-label">Aquacheck:</span>
                    <span class="detail-value">Ceiling</span>
                </div>
                ` : ''}
                ${measurement.hasAquacheckWalls ? `
                <div class="room-detail-item">
                    <span class="detail-label">Aquacheck:</span>
                    <span class="detail-value">Walls</span>
                </div>
                ` : ''}
                ${measurement.openingsArea ? `
                <div class="room-detail-item">
                    <span class="detail-label">Openings:</span>
                    <span class="detail-value">-${measurement.openingsArea}m²</span>
                </div>
                ` : ''}
                <div class="room-detail-item">
                    <span class="detail-label">Ceiling Height:</span>
                    <span class="detail-value">${measurement.ceilingHeight || measurement.wallHeight || state.globalCeilingHeight}m</span>
                </div>
            `;
            
            roomDetails.innerHTML = detailsHtml;
            
            // Add wall segments if available
            if (measurement.segments && measurement.segments.length > 0) {
                const segmentsTitle = document.createElement('div');
                segmentsTitle.className = 'room-detail-item';
                segmentsTitle.style.marginTop = '10px';
                segmentsTitle.innerHTML = '<span class="detail-label">Wall Segments:</span>';
                roomDetails.appendChild(segmentsTitle);
                
                measurement.segments.forEach((seg, segIndex) => {
                    const segItem = document.createElement('div');
                    segItem.className = 'measurement-item';
                    const isSegHovered = isHovered && state.hoveredSegment === segIndex;
                    
                    if (isSegHovered) {
                        segItem.classList.add('highlighted');
                    }
                    
                    segItem.innerHTML = `
                        <div class="measurement-info">
                            <span style="padding-left: 20px;">Wall ${segIndex + 1}</span>
                            <span class="measurement-length">${seg.length.toFixed(2)}m</span>
                        </div>
                    `;
                    
                    segItem.onmouseenter = () => handleSegmentHover(measurement.id, segIndex, true);
                    segItem.onmouseleave = () => handleSegmentHover(measurement.id, segIndex, false);
                    
                    roomDetails.appendChild(segItem);
                });
            }
            
            roomHeader.onclick = (e) => {
                if (e.target.classList.contains('measurement-delete')) {
                    e.stopPropagation();
                    return;
                }
                const isNowOpen = roomDetails.style.display === 'none';
                roomDetails.style.display = isNowOpen ? 'block' : 'none';
                const arrow = roomHeader.querySelector('.room-arrow');
                arrow.classList.toggle('open', isNowOpen);
                
                if (isNowOpen) {
                    state.collapsedGroups.delete(`room-${measurement.id}`);
                } else {
                    state.collapsedGroups.add(`room-${measurement.id}`);
                }
            };
            
            container.appendChild(roomHeader);
            container.appendChild(roomDetails);
            
            return container;
        }

        function createMeasurementItem(measurement, allMeasurements) {
            const item = document.createElement('div');
            item.className = 'measurement-item';
            
            const index = allMeasurements.findIndex(m => m.id === measurement.id);
            const isHovered = index === state.hoveredMeasurement;
            
            if (isHovered) {
                item.classList.add('highlighted');
            }
            
            let displayName = measurement.groupName;
            
            item.innerHTML = `
                <span>${displayName}</span>
                <button class="measurement-delete" onclick="deleteMeasurement(${measurement.id})" title="Delete">×</button>
            `;
            
            item.onmouseenter = () => handleMeasurementHover(measurement.id, true);
            item.onmouseleave = () => handleMeasurementHover(measurement.id, false);
            
            return item;
        }

        function toggleGroupCollapse(key) {
            if (state.collapsedGroups.has(key)) {
                state.collapsedGroups.delete(key);
            } else {
                state.collapsedGroups.add(key);
            }
            updateMeasurementsList();
        }

        function calculateGroupTotal(measurements, itemType) {
            let total = 0;
            
            measurements.forEach(m => {
                if (itemType.unit === 'm') {
                    if (m.height || m.ceilingHeight) {
                        total += m.length * (m.height || m.ceilingHeight || state.globalCeilingHeight);
                    } else {
                        total += m.length || 0;
                    }
                } else if (itemType.unit === 'm2') {
                    total += m.area || 0;
                } else if (itemType.unit === 'Count') {
                    total += 1;
                }
            });
            
            return total;
        }

        function formatValue(value, unit) {
            if (unit === 'Count') {
                return value.toString();
            } else {
                return `${value.toFixed(2)} ${unit}`;
            }
        }

        // Zoom Functions
        function adjustZoom(factor) {
            state.zoom = Math.min(Math.max(state.zoom * factor, 0.1), 20);
            const transform = `translate(calc(-50% + ${state.panOffset.x}px), calc(-50% + ${state.panOffset.y}px)) scale(${state.zoom})`;
            pdfCanvas.style.transform = transform;
            drawingCanvas.style.transform = transform;
        }

        function resetZoom() {
            state.zoom = 1;
            state.panOffset = { x: 0, y: 0 };
            const transform = `translate(-50%, -50%) scale(1)`;
            pdfCanvas.style.transform = transform;
            drawingCanvas.style.transform = transform;
        }

        // Panel Toggle
        function togglePanel() {
            const panel = document.getElementById('rightPanel');
            panel.classList.toggle('collapsed');
            const arrow = panel.querySelector('.panel-toggle');
            arrow.textContent = panel.classList.contains('collapsed') ? '▶' : '◀';
        }

        // Drawing Functions
        function redrawMeasurements() {
            drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            
            getCurrentMeasurements().forEach((m, index) => {
                if (!m.visible) return;
                
                const isHovered = state.hoveredMeasurement === index;
                let color = m.itemType.color;
                
                // Apply aquacheck color if this measurement has it enabled
                const aquacheckColor = '#87CEEB';
                if (m.hasAquacheckCeilings && m.type === 'polygon') {
                    color = aquacheckColor;
                }
                
                drawCtx.strokeStyle = isHovered ? '#ff0066' : color;
                drawCtx.lineWidth = m.lineWidth || 2;
                drawCtx.fillStyle = hexToRgba(color, isHovered ? 0.2 : (m.opacity || 30) / 100);
                
                if (m.type === 'line-chain') {
                    m.segments.forEach((seg, segIndex) => {
                        const isSegHovered = isHovered && state.hoveredSegment === segIndex;
                        drawCtx.strokeStyle = isSegHovered ? '#00d4ff' : (isHovered ? '#ff0066' : color);
                        drawCtx.lineWidth = isSegHovered ? (m.lineWidth || 2) + 2 : (m.lineWidth || 2);
                        
                        drawCtx.beginPath();
                        drawCtx.moveTo(seg.start.x, seg.start.y);
                        drawCtx.lineTo(seg.end.x, seg.end.y);
                        drawCtx.stroke();
                    });
                    
                    if (isHovered && m.segments.length > 0) {
                        const midSeg = m.segments[Math.floor(m.segments.length / 2)];
                        const height = m.height || m.ceilingHeight || state.globalCeilingHeight;
                        const label = m.height ? 
                            `${m.length.toFixed(2)}m × ${height}m = ${(m.length * height).toFixed(2)}m²` :
                            `${m.length.toFixed(2)}m`;
                        drawMeasurementLabel(midSeg.start, midSeg.end, label);
                    }
                    
                } else if (m.type === 'polygon') {
                    // Draw filled polygon
                    drawCtx.beginPath();
                    drawCtx.moveTo(m.points[0].x, m.points[0].y);
                    m.points.forEach(p => drawCtx.lineTo(p.x, p.y));
                    drawCtx.closePath();
                    drawCtx.fill();
                    
                    // Draw individual segments with hover highlighting
                    if (m.segments) {
                        m.segments.forEach((seg, segIndex) => {
                            const isSegHovered = isHovered && state.hoveredSegment === segIndex;
                            drawCtx.strokeStyle = isSegHovered ? '#00d4ff' : (isHovered ? '#ff0066' : color);
                            drawCtx.lineWidth = isSegHovered ? (m.lineWidth || 2) + 2 : (m.lineWidth || 2);
                            
                            drawCtx.beginPath();
                            drawCtx.moveTo(seg.start.x, seg.start.y);
                            drawCtx.lineTo(seg.end.x, seg.end.y);
                            drawCtx.stroke();
                        });
                    } else {
                        drawCtx.stroke();
                    }
                    
                    // Draw offset lines for walls and finish (tightened spacing)
                    if (m.wallType && state.wallType === 'timber') {
                        drawOffsetLines(m.points, m.wallType.color, 2, m.hasAquacheckWalls); // Tightened from 3
                    }
                    if (m.appliedFinish) {
                        drawOffsetLines(m.points, m.appliedFinish.color, 4, false); // Tightened from 6
                    }
                    
                    if (isHovered) {
                        const center = getPolygonCenter(m.points);
                        drawMeasurementLabelAt(center, `${m.area.toFixed(2)}m²`);
                    }
                    
                } else if (m.type === 'count') {
                    drawCountMarker(m.point, m.shape || 'circle', m.size || 20, m.markerColor || m.itemType.color, isHovered);
                }
            });
        }

        function drawOffsetLines(points, color, offset, useAquacheck) {
            const aquacheckColor = '#87CEEB';
            drawCtx.strokeStyle = useAquacheck ? aquacheckColor : color;
            drawCtx.lineWidth = 2;
            
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                
                // Calculate perpendicular offset (tightened spacing)
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                const nx = -dy / len * offset;
                const ny = dx / len * offset;
                
                drawCtx.beginPath();
                drawCtx.moveTo(p1.x + nx, p1.y + ny);
                drawCtx.lineTo(p2.x + nx, p2.y + ny);
                drawCtx.stroke();
            }
        }

        function drawCountMarker(point, shape, size, color, isHovered) {
            drawCtx.fillStyle = hexToRgba(color, isHovered ? 0.5 : 0.3);
            drawCtx.strokeStyle = isHovered ? '#ff0066' : color;
            drawCtx.lineWidth = 2;
            
            switch(shape) {
                case 'circle':
                    drawCtx.beginPath();
                    drawCtx.arc(point.x, point.y, size/2, 0, 2 * Math.PI);
                    drawCtx.fill();
                    drawCtx.stroke();
                    break;
                case 'square':
                    drawCtx.fillRect(point.x - size/2, point.y - size/2, size, size);
                    drawCtx.strokeRect(point.x - size/2, point.y - size/2, size, size);
                    break;
                case 'triangle':
                    drawCtx.beginPath();
                    drawCtx.moveTo(point.x, point.y - size/2);
                    drawCtx.lineTo(point.x - size/2, point.y + size/2);
                    drawCtx.lineTo(point.x + size/2, point.y + size/2);
                    drawCtx.closePath();
                    drawCtx.fill();
                    drawCtx.stroke();
                    break;
                case 'diamond':
                    drawCtx.beginPath();
                    drawCtx.moveTo(point.x, point.y - size/2);
                    drawCtx.lineTo(point.x + size/2, point.y);
                    drawCtx.lineTo(point.x, point.y + size/2);
                    drawCtx.lineTo(point.x - size/2, point.y);
                    drawCtx.closePath();
                    drawCtx.fill();
                    drawCtx.stroke();
                    break;
                case 'cross':
                    drawCtx.beginPath();
                    drawCtx.moveTo(point.x - size/2, point.y - size/2);
                    drawCtx.lineTo(point.x + size/2, point.y + size/2);
                    drawCtx.moveTo(point.x + size/2, point.y - size/2);
                    drawCtx.lineTo(point.x - size/2, point.y + size/2);
                    drawCtx.stroke();
                    break;
            }
        }

        function drawMeasurementLabel(p1, p2, text, offsetFromCursor) {
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;
            
            if (offsetFromCursor) {
                // Calculate angle of line
                const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const offsetDist = 30;
                const offsetX = Math.sin(angle) * offsetDist;
                const offsetY = -Math.cos(angle) * offsetDist;
                drawMeasurementLabelAt({ x: midX + offsetX, y: midY + offsetY }, text);
            } else {
                drawMeasurementLabelAt({ x: midX, y: midY }, text);
            }
        }

        function drawMeasurementLabelAt(point, text) {
            const padding = 5;
            const metrics = drawCtx.measureText(text);
            const width = metrics.width + padding * 2;
            const height = 20;
            
            drawCtx.fillStyle = '#000';
            drawCtx.fillRect(point.x - width/2, point.y - height/2, width, height);
            
            drawCtx.fillStyle = '#00d4ff';
            drawCtx.font = '14px Arial';
            drawCtx.textAlign = 'center';
            drawCtx.textBaseline = 'middle';
            drawCtx.fillText(text, point.x, point.y);
        }

        // Billing Window
        function openBillingWindow() {
            updateBillingData();
            const window = document.getElementById('billingWindow');
            window.style.display = 'block';
            
            // Update page name
            const currentPage = getCurrentPage();
            document.getElementById('billingPageName').textContent = currentPage.name;
        }

        function closeBillingWindow() {
            document.getElementById('billingWindow').style.display = 'none';
        }

        function updateBillingData() {
            const tbody = document.getElementById('billingTableBody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            
            const summary = calculateBillingSummary();
            let subtotal = 0;
            let rowIndex = 0;
            
            Object.values(summary).forEach(item => {
                const cost = item.quantity * item.price;
                subtotal += cost;
                
                const row = document.createElement('tr');
                row.className = 'billing-row';
                row.draggable = true;
                row.dataset.index = rowIndex++;
                row.dataset.itemId = item.id;
                
                row.innerHTML = `
                    <td><input type="text" value="${item.name}" onchange="updateBillingItem('${item.id}', 'name', this.value)"></td>
                    <td><input type="number" value="${item.quantity.toFixed(2)}" step="0.01" onchange="updateBillingItem('${item.id}', 'quantity', this.value)" style="width: 80px; background: transparent; border: none; color: #fff;"></td>
                    <td>$<input type="number" value="${item.price.toFixed(2)}" step="0.01" onchange="updateBillingItem('${item.id}', 'price', this.value)" style="width: 60px; background: transparent; border: none; color: #fff;"></td>
                    <td>${cost.toFixed(2)}</td>
                `;
                
                // Drag handlers
                row.addEventListener('dragstart', handleDragStart);
                row.addEventListener('dragover', handleDragOver);
                row.addEventListener('drop', handleDrop);
                row.addEventListener('dragend', handleDragEnd);
                
                tbody.appendChild(row);
            });
            
            // Update totals with proper formatting
            const gst = subtotal * 0.1;
            const grandTotal = subtotal + gst;
            
            if (document.getElementById('billingSubtotal')) {
                document.getElementById('billingSubtotal').textContent = subtotal.toFixed(2);
                document.getElementById('billingGST').textContent = gst.toFixed(2);
                document.getElementById('billingGrandTotal').textContent = grandTotal.toFixed(2);
            }
        }

        function calculateBillingSummary() {
            const summary = {};
            
            getCurrentMeasurements().forEach(m => {
                // Handle ceiling items
                const key = m.itemType.id;
                if (!summary[key]) {
                    summary[key] = {
                        id: key,
                        name: m.itemType.name,
                        unit: m.itemType.unit,
                        price: m.itemType.price,
                        quantity: 0
                    };
                }
                
                if (m.itemType.unit === 'm') {
                    const height = m.height || m.ceilingHeight || state.globalCeilingHeight;
                    if (m.height || m.ceilingHeight) {
                        summary[key].quantity += m.length * height;
                    } else {
                        summary[key].quantity += m.length;
                    }
                } else if (m.itemType.unit === 'm2') {
                    summary[key].quantity += m.area || 0;
                } else if (m.itemType.unit === 'Count') {
                    summary[key].quantity += 1;
                }
                
                // Handle wall items for polygons
                if (m.type === 'polygon' && m.wallType && state.wallType === 'timber') {
                    const wallKey = m.wallType.id;
                    if (!summary[wallKey]) {
                        summary[wallKey] = {
                            id: wallKey,
                            name: m.wallType.name,
                            unit: m.wallType.unit,
                            price: m.wallType.price,
                            quantity: 0
                        };
                    }
                    const wallHeight = m.wallHeight || m.ceilingHeight || state.globalCeilingHeight;
                    let wallArea = m.perimeter * wallHeight;
                    
                    // Apply openings deduction
                    if (m.openingsArea) {
                        wallArea -= m.openingsArea;
                    }
                    
                    summary[wallKey].quantity += wallArea;
                }
                
                // Handle finish items for polygons (use per-measurement finish)
                if (m.type === 'polygon' && m.appliedFinish) {
                    const finishKey = m.appliedFinish.id;
                    if (!summary[finishKey]) {
                        summary[finishKey] = {
                            id: finishKey,
                            name: m.appliedFinish.name,
                            unit: m.appliedFinish.unit,
                            price: m.appliedFinish.price,
                            quantity: 0
                        };
                    }
                    summary[finishKey].quantity += m.perimeter;
                }
                
                // Handle aquacheck (use per-measurement aquacheck settings)
                if (m.hasAquacheckCeilings && m.type === 'polygon') {
                    const aquaKey = 'ceiling_121';
                    if (!summary[aquaKey]) {
                        const aquaItem = state.itemTypes.Ceilings.find(i => i.id === aquaKey);
                        summary[aquaKey] = {
                            id: aquaKey,
                            name: aquaItem.name,
                            unit: aquaItem.unit,
                            price: aquaItem.price,
                            quantity: 0
                        };
                    }
                    summary[aquaKey].quantity += m.area;
                }
                
                if (m.hasAquacheckWalls && m.type === 'polygon' && m.wallType) {
                    const aquaKey = 'wall_216';
                    if (!summary[aquaKey]) {
                        const aquaItem = state.itemTypes.Walls.find(i => i.id === aquaKey);
                        summary[aquaKey] = {
                            id: aquaKey,
                            name: aquaItem.name,
                            unit: aquaItem.unit,
                            price: aquaItem.price,
                            quantity: 0
                        };
                    }
                    const wallHeight = m.wallHeight || m.ceilingHeight || state.globalCeilingHeight;
                    let wallArea = m.perimeter * wallHeight;
                    
                    // Apply openings deduction
                    if (m.openingsArea) {
                        wallArea -= m.openingsArea;
                    }
                    
                    summary[aquaKey].quantity += wallArea;
                }
                
                // Handle insulation deduction for openings
                if (m.type === 'polygon' && m.openingsArea && state.wallType === 'timber') {
                    // Find any R2 or R2.5 insulation in the summary
                    ['wall_201', 'wall_202'].forEach(insulationId => {
                        if (summary[insulationId]) {
                            summary[insulationId].quantity -= m.openingsArea;
                        }
                    });
                }
            });
            
            // Remove items with zero or negative quantity
            Object.keys(summary).forEach(key => {
                if (summary[key].quantity <= 0) {
                    delete summary[key];
                }
            });
            
            return summary;
        }

        // Estimate Window
        function openEstimateWindow() {
            // Check for missing items first
            if (!checkMissingItems()) {
                return;
            }
            
            const window = document.getElementById('estimateWindow');
            window.style.display = 'block';
            
            renderEstimate();
        }

        function checkMissingItems() {
            const missing = [];
            const summary = calculateBillingSummary();
            const itemIds = Object.keys(summary);
            
            if (state.wallType === 'brick') {
                // Check for Brick wall requirements
                if (!itemIds.some(id => id === 'ceiling_129')) {
                    missing.push('R4 Insulation');
                }
                if (!state.currentFinish && !getCurrentMeasurements().some(m => m.appliedFinish)) {
                    missing.push('A selected Finish');
                }
                if (state.currentAquacheckCeilings || state.currentAquacheckWalls) {
                    missing.push('Aquacheck board is selected (unusual for brick walls)');
                }
            } else if (state.wallType === 'timber') {
                // Check for Timber wall requirements
                if (!itemIds.some(id => id === 'wall_201' || id === 'wall_202')) {
                    missing.push('R2 or R2.5 HD Insulation');
                }
                if (!state.currentFinish && !getCurrentMeasurements().some(m => m.appliedFinish)) {
                    missing.push('A selected Finish');
                }
                if (!itemIds.some(id => id === 'ceiling_129')) {
                    missing.push('R4 Insulation');
                }
                if (!state.currentAquacheckCeilings && !state.currentAquacheckWalls && 
                    !getCurrentMeasurements().some(m => m.hasAquacheckCeilings || m.hasAquacheckWalls)) {
                    missing.push('No Aquacheck board selected');
                }
                if (!itemIds.some(id => id === 'wall_205' || id === 'wall_206' || id === 'ceiling_116' || id === 'ceiling_117')) {
                    missing.push('Exangle Bead LM or Exangle Bead 2.7m');
                }
            }
            
            if (missing.length > 0) {
                showReminderDialog(missing);
                return false;
            }
            
            return true;
        }

        function showReminderDialog(missing) {
            const dialog = document.getElementById('reminderDialog');
            const content = document.getElementById('reminderContent');
            
            content.innerHTML = '<div class="reminder-list">';
            missing.forEach(item => {
                content.innerHTML += `<div class="reminder-item">${item}</div>`;
            });
            content.innerHTML += '</div>';
            
            dialog.style.display = 'block';
        }

        function closeReminderDialog() {
            document.getElementById('reminderDialog').style.display = 'none';
        }

        function continueEstimate() {
            closeReminderDialog();
            const window = document.getElementById('estimateWindow');
            window.style.display = 'block';
            renderEstimate();
        }

        function closeEstimateWindow() {
            document.getElementById('estimateWindow').style.display = 'none';
        }

        function renderEstimate() {
            const content = document.getElementById('estimateContent');
            content.innerHTML = '';
            
            let grandTotal = 0;
            
            state.pages.forEach((page, pageIndex) => {
                if (page.measurements.length === 0) return;
                
                const section = document.createElement('div');
                section.className = 'page-section';
                
                const header = document.createElement('div');
                header.className = 'page-section-header';
                header.textContent = page.name;
                
                const sectionContent = document.createElement('div');
                sectionContent.className = 'page-section-content';
                
                // Calculate billing for this page
                const oldPageIndex = state.currentPageIndex;
                state.currentPageIndex = pageIndex;
                const summary = calculateBillingSummary();
                state.currentPageIndex = oldPageIndex;
                
                const table = document.createElement('table');
                table.className = 'billing-table';
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th>Item</th>
                            <th>Quantity</th>
                            <th>Price</th>
                            <th>Total</th>
                        </tr>
                    </thead>
                    <tbody>
                `;
                
                let pageSubtotal = 0;
                
                Object.values(summary).forEach(item => {
                    const cost = item.quantity * item.price;
                    pageSubtotal += cost;
                    
                    const row = table.insertRow();
                    row.innerHTML = `
                        <td>${item.name}</td>
                        <td>${formatValue(item.quantity, item.unit)}</td>
                        <td>${item.price.toFixed(2)}</td>
                        <td>${cost.toFixed(2)}</td>
                    `;
                });
                
                table.innerHTML += '</tbody>';
                sectionContent.appendChild(table);
                
                // Page totals
                const pageGst = pageSubtotal * 0.1;
                const pageTotal = pageSubtotal + pageGst;
                grandTotal += pageTotal;
                
                const totalsDiv = document.createElement('div');
                totalsDiv.className = 'billing-totals';
                totalsDiv.innerHTML = `
                    <div class="billing-total-row">
                        <span>Subtotal:</span>
                        <span>${pageSubtotal.toFixed(2)}</span>
                    </div>
                    <div class="billing-total-row">
                        <span>GST (10%):</span>
                        <span>${pageGst.toFixed(2)}</span>
                    </div>
                    <div class="billing-total-row" style="font-weight: 600; color: #00d4ff;">
                        <span>Page Total:</span>
                        <span>${pageTotal.toFixed(2)}</span>
                    </div>
                `;
                sectionContent.appendChild(totalsDiv);
                
                section.appendChild(header);
                section.appendChild(sectionContent);
                content.appendChild(section);
            });
            
            // Grand total
            const grandTotalDiv = document.createElement('div');
            grandTotalDiv.style.marginTop = '30px';
            grandTotalDiv.style.padding = '20px';
            grandTotalDiv.style.background = '#00d4ff20';
            grandTotalDiv.style.border = '2px solid #00d4ff';
            grandTotalDiv.style.borderRadius = '8px';
            grandTotalDiv.innerHTML = `
                <div class="billing-total-row grand-total">
                    <span>GRAND TOTAL (All Pages):</span>
                    <span>${grandTotal.toFixed(2)}</span>
                </div>
            `;
            content.appendChild(grandTotalDiv);
        }

        // Dragging for windows
        function startDragBilling(e) {
            state.isDraggingBilling = true;
            const window = document.getElementById('billingWindow');
            const rect = window.getBoundingClientRect();
            state.billingDragOffset = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            
            document.addEventListener('mousemove', dragBilling);
            document.addEventListener('mouseup', stopDragBilling);
        }

        function dragBilling(e) {
            if (!state.isDraggingBilling) return;
            
            const window = document.getElementById('billingWindow');
            window.style.left = (e.clientX - state.billingDragOffset.x) + 'px';
            window.style.top = (e.clientY - state.billingDragOffset.y) + 'px';
            window.style.transform = 'none';
        }

        function stopDragBilling() {
            state.isDraggingBilling = false;
            document.removeEventListener('mousemove', dragBilling);
            document.removeEventListener('mouseup', stopDragBilling);
        }

        function startDragEstimate(e) {
            state.isDraggingEstimate = true;
            const window = document.getElementById('estimateWindow');
            const rect = window.getBoundingClientRect();
            state.estimateDragOffset = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            
            document.addEventListener('mousemove', dragEstimate);
            document.addEventListener('mouseup', stopDragEstimate);
        }

        function dragEstimate(e) {
            if (!state.isDraggingEstimate) return;
            
            const window = document.getElementById('estimateWindow');
            window.style.left = (e.clientX - state.estimateDragOffset.x) + 'px';
            window.style.top = (e.clientY - state.estimateDragOffset.y) + 'px';
            window.style.transform = 'none';
        }

        function stopDragEstimate() {
            state.isDraggingEstimate = false;
            document.removeEventListener('mousemove', dragEstimate);
            document.removeEventListener('mouseup', stopDragEstimate);
        }
        
        // Room Name Dialog dragging
        function startDragRoomName(e) {
            state.isDraggingRoomName = true;
            const dialog = document.getElementById('roomNameDialog');
            const rect = dialog.getBoundingClientRect();
            state.roomNameDragOffset = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            
            document.addEventListener('mousemove', dragRoomName);
            document.addEventListener('mouseup', stopDragRoomName);
        }

        function dragRoomName(e) {
            if (!state.isDraggingRoomName) return;
            
            const dialog = document.getElementById('roomNameDialog');
            dialog.style.left = (e.clientX - state.roomNameDragOffset.x) + 'px';
            dialog.style.top = (e.clientY - state.roomNameDragOffset.y) + 'px';
            dialog.style.transform = 'none';
        }

        function stopDragRoomName() {
            state.isDraggingRoomName = false;
            document.removeEventListener('mousemove', dragRoomName);
            document.removeEventListener('mouseup', stopDragRoomName);
        }

        // Drag and drop for billing rows
        let draggedRow = null;

        function handleDragStart(e) {
            draggedRow = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            if (draggedRow !== this) {
                const tbody = this.parentNode;
                const allRows = Array.from(tbody.querySelectorAll('.billing-row'));
                const draggedIndex = allRows.indexOf(draggedRow);
                const targetIndex = allRows.indexOf(this);
                
                if (draggedIndex < targetIndex) {
                    tbody.insertBefore(draggedRow, this.nextSibling);
                } else {
                    tbody.insertBefore(draggedRow, this);
                }
            }
            
            return false;
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
        }
        
        // Billing Item Updates
        function updateBillingItem(itemId, field, value) {
            // This would update the billing summary in memory
            // For now, just update the display
            updateBillingData();
        }

        // Profile Management
        function openProfileDialog() {
            const dialog = document.getElementById('profileDialog');
            dialog.style.display = 'block';
            updateProfileSelect();
        }

        function closeProfileDialog() {
            document.getElementById('profileDialog').style.display = 'none';
        }

        function updateProfileSelect() {
            const select = document.getElementById('profileSelect');
            select.innerHTML = '';
            
            Object.keys(state.profiles).forEach(profile => {
                const option = document.createElement('option');
                option.value = profile;
                option.textContent = profile;
                option.selected = profile === state.currentProfile;
                select.appendChild(option);
            });
        }

        function selectProfile() {
            const select = document.getElementById('profileSelect');
            const newProfile = select.value;
            
            if (newProfile !== state.currentProfile) {
                // Save current profile first
                saveProfiles();
                
                // Switch to new profile
                state.currentProfile = newProfile;
                state.itemTypes = JSON.parse(JSON.stringify(state.profiles[newProfile]));
                
                // Update UI
                renderItemTypes();
                populateFinishOptions();
                populateWallTypeOptions();
            }
            
            closeProfileDialog();
        }

        function loadProfiles() {
            const saved = localStorage.getItem('plasterbird_profiles');
            if (saved) {
                state.profiles = JSON.parse(saved);
            }
        }

        function saveProfiles() {
            state.profiles[state.currentProfile] = JSON.parse(JSON.stringify(state.itemTypes));
            localStorage.setItem('plasterbird_profiles', JSON.stringify(state.profiles));
        }

        function switchProfileInEditor() {
            const dropdown = document.getElementById('editorProfileDropdown');
            const newProfile = dropdown.value;
            
            if (newProfile !== state.currentProfile) {
                // Save current profile first
                saveProfiles();
                
                // Switch to new profile
                state.currentProfile = newProfile;
                state.itemTypes = JSON.parse(JSON.stringify(state.profiles[newProfile]));
                
                // Re-render items editor
                renderItemsEditor();
            }
        }

        function saveCurrentProfile() {
            saveProfiles();
            alert(`Profile "${state.currentProfile}" saved successfully!`);
        }

        function addProfile() {
            const name = prompt('Enter profile name:');
            if (name && !state.profiles[name]) {
                state.profiles[name] = JSON.parse(JSON.stringify(defaultItemTypes));
                state.currentProfile = name;
                state.itemTypes = JSON.parse(JSON.stringify(defaultItemTypes));
                updateProfileSelect();
                saveProfiles();
                
                // Update items editor if open
                if (document.getElementById('itemsEditor').style.display === 'flex') {
                    renderItemsEditor();
                }
            }
        }

        function renameProfile() {
            if (state.currentProfile === 'default') {
                alert('Cannot rename default profile');
                return;
            }
            
            const newName = prompt('Enter new name:', state.currentProfile);
            if (newName && newName !== state.currentProfile && !state.profiles[newName]) {
                state.profiles[newName] = state.profiles[state.currentProfile];
                delete state.profiles[state.currentProfile];
                state.currentProfile = newName;
                updateProfileSelect();
                saveProfiles();
                
                // Update items editor if open
                if (document.getElementById('itemsEditor').style.display === 'flex') {
                    renderItemsEditor();
                }
            }
        }

        function exportPriceList() {
            // This would generate a PDF of the price list
            // For now, just alert
            alert('Export to PDF functionality would be implemented here');
        }

        // Room Detection
        function detectRoomBoundaries(clickPoint) {
            // This is a simplified room detection algorithm
            // In a real implementation, you would use image processing to detect walls
            
            // For now, let's try to find a closed area around the click point
            // by looking for dark pixels in the PDF canvas
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = pdfCanvas.width;
            tempCanvas.height = pdfCanvas.height;
            
            // Copy PDF canvas
            tempCtx.drawImage(pdfCanvas, 0, 0);
            
            // Get image data
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            // Try to trace room boundary from click point
            // This is a placeholder - real implementation would be more sophisticated
            const boundary = [];
            const radius = 200; // Search radius
            const steps = 36; // Number of rays to cast
            
            for (let i = 0; i < steps; i++) {
                const angle = (i / steps) * Math.PI * 2;
                const dx = Math.cos(angle);
                const dy = Math.sin(angle);
                
                // Cast ray from click point
                for (let r = 10; r < radius; r += 2) {
                    const x = Math.floor(clickPoint.x + dx * r);
                    const y = Math.floor(clickPoint.y + dy * r);
                    
                    if (x >= 0 && x < tempCanvas.width && y >= 0 && y < tempCanvas.height) {
                        const idx = (y * tempCanvas.width + x) * 4;
                        const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        
                        // If we hit a dark pixel (wall), record this point
                        if (brightness < 128) {
                            boundary.push({ x, y });
                            break;
                        }
                    }
                }
            }
            
            // Simplify boundary points
            if (boundary.length >= 8) {
                // Reduce points to create a simpler polygon
                const simplified = [];
                const step = Math.floor(boundary.length / 8);
                for (let i = 0; i < boundary.length; i += step) {
                    simplified.push(boundary[i]);
                }
                return simplified;
            }
            
            return null;
        }

        // Utility Functions
        function calculateDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        function calculatePolygonArea(points) {
            let area = 0;
            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;
                area += points[i].x * points[j].y;
                area -= points[j].x * points[i].y;
            }
            return Math.abs(area / 2);
        }

        function getPolygonCenter(points) {
            let x = 0, y = 0;
            points.forEach(p => {
                x += p.x;
                y += p.y;
            });
            return { x: x / points.length, y: y / points.length };
        }

        function distanceToLine(p1, p2, point) {
            const A = point.x - p1.x;
            const B = point.y - p1.y;
            const C = p2.x - p1.x;
            const D = p2.y - p1.y;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) param = dot / lenSq;
            
            let xx, yy;
            
            if (param < 0) {
                xx = p1.x;
                yy = p1.y;
            } else if (param > 1) {
                xx = p2.x;
                yy = p2.y;
            } else {
                xx = p1.x + param * C;
                yy = p1.y + param * D;
            }
            
            const dx = point.x - xx;
            const dy = point.y - yy;
            
            return Math.sqrt(dx * dx + dy * dy);
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Initialize the application
        init();
    </script>
</body>
</html>